// node_modules/@sentry/types/esm/severity.js
var Severity;
(function(Severity2) {
  Severity2["Fatal"] = "fatal";
  Severity2["Error"] = "error";
  Severity2["Warning"] = "warning";
  Severity2["Log"] = "log";
  Severity2["Info"] = "info";
  Severity2["Debug"] = "debug";
  Severity2["Critical"] = "critical";
})(Severity || (Severity = {}));

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}

// node_modules/@sentry/utils/esm/env.js
function isBrowserBundle() {
  return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
}

// node_modules/@sentry/utils/esm/node.js
function isNodeEnv() {
  return !isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
}
function dynamicRequire(mod, request) {
  return mod.require(request);
}
function loadModule(moduleName) {
  var mod;
  try {
    mod = dynamicRequire(module, moduleName);
  } catch (e) {
  }
  try {
    var cwd = dynamicRequire(module, "process").cwd;
    mod = dynamicRequire(module, cwd() + "/node_modules/" + moduleName);
  } catch (e) {
  }
  return mod;
}

// node_modules/@sentry/utils/esm/global.js
var fallbackGlobalObject = {};
function getGlobalObject() {
  return isNodeEnv() ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : fallbackGlobalObject;
}
function getGlobalSingleton(name, creator, obj) {
  var global4 = obj || getGlobalObject();
  var __SENTRY__ = global4.__SENTRY__ = global4.__SENTRY__ || {};
  var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
  return singleton;
}

// node_modules/@sentry/utils/esm/is.js
var objectToString = Object.prototype.toString;
function isError(wat) {
  switch (objectToString.call(wat)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return true;
    default:
      return isInstanceOf(wat, Error);
  }
}
function isBuiltin(wat, ty) {
  return objectToString.call(wat) === "[object " + ty + "]";
}
function isErrorEvent(wat) {
  return isBuiltin(wat, "ErrorEvent");
}
function isDOMError(wat) {
  return isBuiltin(wat, "DOMError");
}
function isDOMException(wat) {
  return isBuiltin(wat, "DOMException");
}
function isString(wat) {
  return isBuiltin(wat, "String");
}
function isPrimitive(wat) {
  return wat === null || typeof wat !== "object" && typeof wat !== "function";
}
function isPlainObject(wat) {
  return isBuiltin(wat, "Object");
}
function isEvent(wat) {
  return typeof Event !== "undefined" && isInstanceOf(wat, Event);
}
function isElement(wat) {
  return typeof Element !== "undefined" && isInstanceOf(wat, Element);
}
function isRegExp(wat) {
  return isBuiltin(wat, "RegExp");
}
function isThenable(wat) {
  return Boolean(wat && wat.then && typeof wat.then === "function");
}
function isSyntheticEvent(wat) {
  return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
}
function isNaN2(wat) {
  return typeof wat === "number" && wat !== wat;
}
function isInstanceOf(wat, base) {
  try {
    return wat instanceof base;
  } catch (_e) {
    return false;
  }
}

// node_modules/@sentry/utils/esm/browser.js
function htmlTreeAsString(elem, keyAttrs) {
  try {
    var currentElem = elem;
    var MAX_TRAVERSE_HEIGHT = 5;
    var MAX_OUTPUT_LEN = 80;
    var out = [];
    var height = 0;
    var len = 0;
    var separator = " > ";
    var sepLength = separator.length;
    var nextStr = void 0;
    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = _htmlElementAsString(currentElem, keyAttrs);
      if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN) {
        break;
      }
      out.push(nextStr);
      len += nextStr.length;
      currentElem = currentElem.parentNode;
    }
    return out.reverse().join(separator);
  } catch (_oO) {
    return "<unknown>";
  }
}
function _htmlElementAsString(el, keyAttrs) {
  var elem = el;
  var out = [];
  var className;
  var classes;
  var key;
  var attr;
  var i;
  if (!elem || !elem.tagName) {
    return "";
  }
  out.push(elem.tagName.toLowerCase());
  var keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter(function(keyAttr) {
    return elem.getAttribute(keyAttr);
  }).map(function(keyAttr) {
    return [keyAttr, elem.getAttribute(keyAttr)];
  }) : null;
  if (keyAttrPairs && keyAttrPairs.length) {
    keyAttrPairs.forEach(function(keyAttrPair) {
      out.push("[" + keyAttrPair[0] + '="' + keyAttrPair[1] + '"]');
    });
  } else {
    if (elem.id) {
      out.push("#" + elem.id);
    }
    className = elem.className;
    if (className && isString(className)) {
      classes = className.split(/\s+/);
      for (i = 0; i < classes.length; i++) {
        out.push("." + classes[i]);
      }
    }
  }
  var allowedAttrs = ["type", "name", "title", "alt"];
  for (i = 0; i < allowedAttrs.length; i++) {
    key = allowedAttrs[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.push("[" + key + '="' + attr + '"]');
    }
  }
  return out.join("");
}
function getLocationHref() {
  var global4 = getGlobalObject();
  try {
    return global4.document.location.href;
  } catch (oO) {
    return "";
  }
}

// node_modules/@sentry/utils/esm/string.js
function truncate(str, max) {
  if (max === void 0) {
    max = 0;
  }
  if (typeof str !== "string" || max === 0) {
    return str;
  }
  return str.length <= max ? str : str.substr(0, max) + "...";
}
function safeJoin(input, delimiter) {
  if (!Array.isArray(input)) {
    return "";
  }
  var output = [];
  for (var i = 0; i < input.length; i++) {
    var value = input[i];
    try {
      output.push(String(value));
    } catch (e) {
      output.push("[value cannot be serialized]");
    }
  }
  return output.join(delimiter);
}
function isMatchingPattern(value, pattern) {
  if (!isString(value)) {
    return false;
  }
  if (isRegExp(pattern)) {
    return pattern.test(value);
  }
  if (typeof pattern === "string") {
    return value.indexOf(pattern) !== -1;
  }
  return false;
}

// node_modules/@sentry/utils/esm/object.js
function fill(source, name, replacementFactory) {
  if (!(name in source)) {
    return;
  }
  var original = source[name];
  var wrapped = replacementFactory(original);
  if (typeof wrapped === "function") {
    try {
      markFunctionWrapped(wrapped, original);
    } catch (_Oo) {
    }
  }
  source[name] = wrapped;
}
function addNonEnumerableProperty(obj, name, value) {
  Object.defineProperty(obj, name, {
    value,
    writable: true,
    configurable: true
  });
}
function markFunctionWrapped(wrapped, original) {
  var proto = original.prototype || {};
  wrapped.prototype = original.prototype = proto;
  addNonEnumerableProperty(wrapped, "__sentry_original__", original);
}
function getOriginalFunction(func) {
  return func.__sentry_original__;
}
function urlEncode(object) {
  return Object.keys(object).map(function(key) {
    return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]);
  }).join("&");
}
function convertToPlainObject(value) {
  var newObj = value;
  if (isError(value)) {
    newObj = __assign({ message: value.message, name: value.name, stack: value.stack }, getOwnProperties(value));
  } else if (isEvent(value)) {
    var event_1 = value;
    newObj = __assign({ type: event_1.type, target: serializeEventTarget(event_1.target), currentTarget: serializeEventTarget(event_1.currentTarget) }, getOwnProperties(event_1));
    if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
      newObj.detail = event_1.detail;
    }
  }
  return newObj;
}
function serializeEventTarget(target) {
  try {
    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
  } catch (_oO) {
    return "<unknown>";
  }
}
function getOwnProperties(obj) {
  var extractedProps = {};
  for (var property in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      extractedProps[property] = obj[property];
    }
  }
  return extractedProps;
}
function extractExceptionKeysForMessage(exception, maxLength) {
  if (maxLength === void 0) {
    maxLength = 40;
  }
  var keys = Object.keys(convertToPlainObject(exception));
  keys.sort();
  if (!keys.length) {
    return "[object has no keys]";
  }
  if (keys[0].length >= maxLength) {
    return truncate(keys[0], maxLength);
  }
  for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
    var serialized = keys.slice(0, includedKeys).join(", ");
    if (serialized.length > maxLength) {
      continue;
    }
    if (includedKeys === keys.length) {
      return serialized;
    }
    return truncate(serialized, maxLength);
  }
  return "";
}
function dropUndefinedKeys(val) {
  var e_1, _a;
  if (isPlainObject(val)) {
    var rv = {};
    try {
      for (var _b = __values(Object.keys(val)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var key = _c.value;
        if (typeof val[key] !== "undefined") {
          rv[key] = dropUndefinedKeys(val[key]);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return rv;
  }
  if (Array.isArray(val)) {
    return val.map(dropUndefinedKeys);
  }
  return val;
}

// node_modules/@sentry/utils/esm/misc.js
function uuid4() {
  var global4 = getGlobalObject();
  var crypto = global4.crypto || global4.msCrypto;
  if (!(crypto === void 0) && crypto.getRandomValues) {
    var arr = new Uint16Array(8);
    crypto.getRandomValues(arr);
    arr[3] = arr[3] & 4095 | 16384;
    arr[4] = arr[4] & 16383 | 32768;
    var pad = function(num) {
      var v = num.toString(16);
      while (v.length < 4) {
        v = "0" + v;
      }
      return v;
    };
    return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
  }
  return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0;
    var v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function parseUrl(url) {
  if (!url) {
    return {};
  }
  var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!match) {
    return {};
  }
  var query = match[6] || "";
  var fragment = match[8] || "";
  return {
    host: match[4],
    path: match[5],
    protocol: match[2],
    relative: match[5] + query + fragment
  };
}
function getFirstException(event) {
  return event.exception && event.exception.values ? event.exception.values[0] : void 0;
}
function getEventDescription(event) {
  var message = event.message, eventId = event.event_id;
  if (message) {
    return message;
  }
  var firstException = getFirstException(event);
  if (firstException) {
    if (firstException.type && firstException.value) {
      return firstException.type + ": " + firstException.value;
    }
    return firstException.type || firstException.value || eventId || "<unknown>";
  }
  return eventId || "<unknown>";
}
function addExceptionTypeValue(event, value, type) {
  var exception = event.exception = event.exception || {};
  var values = exception.values = exception.values || [];
  var firstException = values[0] = values[0] || {};
  if (!firstException.value) {
    firstException.value = value || "";
  }
  if (!firstException.type) {
    firstException.type = type || "Error";
  }
}
function addExceptionMechanism(event, newMechanism) {
  var firstException = getFirstException(event);
  if (!firstException) {
    return;
  }
  var defaultMechanism = { type: "generic", handled: true };
  var currentMechanism = firstException.mechanism;
  firstException.mechanism = __assign(__assign(__assign({}, defaultMechanism), currentMechanism), newMechanism);
  if (newMechanism && "data" in newMechanism) {
    var mergedData = __assign(__assign({}, currentMechanism && currentMechanism.data), newMechanism.data);
    firstException.mechanism.data = mergedData;
  }
}
function stripUrlQueryAndFragment(urlPath) {
  return urlPath.split(/[\?#]/, 1)[0];
}
function checkOrSetAlreadyCaught(exception) {
  if (exception && exception.__sentry_captured__) {
    return true;
  }
  try {
    addNonEnumerableProperty(exception, "__sentry_captured__", true);
  } catch (err) {
  }
  return false;
}

// node_modules/@sentry/utils/esm/tracing.js
var TRACEPARENT_REGEXP = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
function extractTraceparentData(traceparent) {
  var matches = traceparent.match(TRACEPARENT_REGEXP);
  if (matches) {
    var parentSampled = void 0;
    if (matches[3] === "1") {
      parentSampled = true;
    } else if (matches[3] === "0") {
      parentSampled = false;
    }
    return {
      traceId: matches[1],
      parentSampled,
      parentSpanId: matches[2]
    };
  }
  return void 0;
}

// node_modules/@sentry/utils/esm/async.js
function forget(promise) {
  void promise.then(null, function(e) {
    console.error(e);
  });
}

// node_modules/@sentry/utils/esm/polyfill.js
var setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
function mixinProperties(obj, proto) {
  for (var prop in proto) {
    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
      obj[prop] = proto[prop];
    }
  }
  return obj;
}

// node_modules/@sentry/utils/esm/error.js
var SentryError = function(_super) {
  __extends(SentryError2, _super);
  function SentryError2(message) {
    var _newTarget = this.constructor;
    var _this = _super.call(this, message) || this;
    _this.message = message;
    _this.name = _newTarget.prototype.constructor.name;
    setPrototypeOf(_this, _newTarget.prototype);
    return _this;
  }
  return SentryError2;
}(Error);

// node_modules/@sentry/utils/esm/flags.js
var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

// node_modules/@sentry/utils/esm/dsn.js
var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(protocol) {
  return protocol === "http" || protocol === "https";
}
function dsnToString(dsn, withPassword) {
  if (withPassword === void 0) {
    withPassword = false;
  }
  var host = dsn.host, path = dsn.path, pass = dsn.pass, port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol, publicKey = dsn.publicKey;
  return protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : "") + ("@" + host + (port ? ":" + port : "") + "/" + (path ? path + "/" : path) + projectId);
}
function dsnFromString(str) {
  var match = DSN_REGEX.exec(str);
  if (!match) {
    throw new SentryError("Invalid Sentry Dsn: " + str);
  }
  var _a = __read(match.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? "" : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? "" : _c, lastPath = _a[5];
  var path = "";
  var projectId = lastPath;
  var split = projectId.split("/");
  if (split.length > 1) {
    path = split.slice(0, -1).join("/");
    projectId = split.pop();
  }
  if (projectId) {
    var projectMatch = projectId.match(/^\d+/);
    if (projectMatch) {
      projectId = projectMatch[0];
    }
  }
  return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
}
function dsnFromComponents(components) {
  if ("user" in components && !("publicKey" in components)) {
    components.publicKey = components.user;
  }
  return {
    user: components.publicKey || "",
    protocol: components.protocol,
    publicKey: components.publicKey || "",
    pass: components.pass || "",
    host: components.host,
    port: components.port || "",
    path: components.path || "",
    projectId: components.projectId
  };
}
function validateDsn(dsn) {
  if (!IS_DEBUG_BUILD) {
    return;
  }
  var port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol;
  var requiredComponents = ["protocol", "publicKey", "host", "projectId"];
  requiredComponents.forEach(function(component) {
    if (!dsn[component]) {
      throw new SentryError("Invalid Sentry Dsn: " + component + " missing");
    }
  });
  if (!projectId.match(/^\d+$/)) {
    throw new SentryError("Invalid Sentry Dsn: Invalid projectId " + projectId);
  }
  if (!isValidProtocol(protocol)) {
    throw new SentryError("Invalid Sentry Dsn: Invalid protocol " + protocol);
  }
  if (port && isNaN(parseInt(port, 10))) {
    throw new SentryError("Invalid Sentry Dsn: Invalid port " + port);
  }
  return true;
}
function makeDsn(from) {
  var components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
  validateDsn(components);
  return components;
}

// node_modules/@sentry/utils/esm/enums.js
var SeverityLevels2 = ["fatal", "error", "warning", "log", "info", "debug", "critical"];

// node_modules/@sentry/utils/esm/logger.js
var global2 = getGlobalObject();
var PREFIX = "Sentry Logger ";
var CONSOLE_LEVELS = ["debug", "info", "warn", "error", "log", "assert"];
function consoleSandbox(callback) {
  var global4 = getGlobalObject();
  if (!("console" in global4)) {
    return callback();
  }
  var originalConsole = global4.console;
  var wrappedLevels = {};
  CONSOLE_LEVELS.forEach(function(level) {
    var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
    if (level in global4.console && originalWrappedFunc) {
      wrappedLevels[level] = originalConsole[level];
      originalConsole[level] = originalWrappedFunc;
    }
  });
  try {
    return callback();
  } finally {
    Object.keys(wrappedLevels).forEach(function(level) {
      originalConsole[level] = wrappedLevels[level];
    });
  }
}
function makeLogger() {
  var enabled = false;
  var logger2 = {
    enable: function() {
      enabled = true;
    },
    disable: function() {
      enabled = false;
    }
  };
  if (IS_DEBUG_BUILD) {
    CONSOLE_LEVELS.forEach(function(name) {
      logger2[name] = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (enabled) {
          consoleSandbox(function() {
            var _a;
            (_a = global2.console)[name].apply(_a, __spread([PREFIX + "[" + name + "]:"], args));
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach(function(name) {
      logger2[name] = function() {
        return void 0;
      };
    });
  }
  return logger2;
}
var logger;
if (IS_DEBUG_BUILD) {
  logger = getGlobalSingleton("logger", makeLogger);
} else {
  logger = makeLogger();
}

// node_modules/@sentry/utils/esm/stacktrace.js
var STACKTRACE_LIMIT = 50;
function createStackParser() {
  var parsers = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    parsers[_i] = arguments[_i];
  }
  var sortedParsers = parsers.sort(function(a, b) {
    return a[0] - b[0];
  }).map(function(p) {
    return p[1];
  });
  return function(stack, skipFirst) {
    var e_1, _a, e_2, _b;
    if (skipFirst === void 0) {
      skipFirst = 0;
    }
    var frames = [];
    try {
      for (var _c = __values(stack.split("\n").slice(skipFirst)), _d = _c.next(); !_d.done; _d = _c.next()) {
        var line = _d.value;
        try {
          for (var sortedParsers_1 = (e_2 = void 0, __values(sortedParsers)), sortedParsers_1_1 = sortedParsers_1.next(); !sortedParsers_1_1.done; sortedParsers_1_1 = sortedParsers_1.next()) {
            var parser = sortedParsers_1_1.value;
            var frame = parser(line);
            if (frame) {
              frames.push(frame);
              break;
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (sortedParsers_1_1 && !sortedParsers_1_1.done && (_b = sortedParsers_1.return))
              _b.call(sortedParsers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a = _c.return))
          _a.call(_c);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return stripSentryFramesAndReverse(frames);
  };
}
function stripSentryFramesAndReverse(stack) {
  if (!stack.length) {
    return [];
  }
  var localStack = stack;
  var firstFrameFunction = localStack[0].function || "";
  var lastFrameFunction = localStack[localStack.length - 1].function || "";
  if (firstFrameFunction.indexOf("captureMessage") !== -1 || firstFrameFunction.indexOf("captureException") !== -1) {
    localStack = localStack.slice(1);
  }
  if (lastFrameFunction.indexOf("sentryWrapped") !== -1) {
    localStack = localStack.slice(0, -1);
  }
  return localStack.slice(0, STACKTRACE_LIMIT).map(function(frame) {
    return __assign(__assign({}, frame), { filename: frame.filename || localStack[0].filename, function: frame.function || "?" });
  }).reverse();
}
var defaultFunctionName = "<anonymous>";
function getFunctionName(fn) {
  try {
    if (!fn || typeof fn !== "function") {
      return defaultFunctionName;
    }
    return fn.name || defaultFunctionName;
  } catch (e) {
    return defaultFunctionName;
  }
}

// node_modules/@sentry/utils/esm/supports.js
function supportsFetch() {
  if (!("fetch" in getGlobalObject())) {
    return false;
  }
  try {
    new Headers();
    new Request("");
    new Response();
    return true;
  } catch (e) {
    return false;
  }
}
function isNativeFetch(func) {
  return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
}
function supportsNativeFetch() {
  if (!supportsFetch()) {
    return false;
  }
  var global4 = getGlobalObject();
  if (isNativeFetch(global4.fetch)) {
    return true;
  }
  var result = false;
  var doc = global4.document;
  if (doc && typeof doc.createElement === "function") {
    try {
      var sandbox = doc.createElement("iframe");
      sandbox.hidden = true;
      doc.head.appendChild(sandbox);
      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
        result = isNativeFetch(sandbox.contentWindow.fetch);
      }
      doc.head.removeChild(sandbox);
    } catch (err) {
      IS_DEBUG_BUILD && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
    }
  }
  return result;
}
function supportsReferrerPolicy() {
  if (!supportsFetch()) {
    return false;
  }
  try {
    new Request("_", {
      referrerPolicy: "origin"
    });
    return true;
  } catch (e) {
    return false;
  }
}
function supportsHistory() {
  var global4 = getGlobalObject();
  var chrome = global4.chrome;
  var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
  var hasHistoryApi = "history" in global4 && !!global4.history.pushState && !!global4.history.replaceState;
  return !isChromePackagedApp && hasHistoryApi;
}

// node_modules/@sentry/utils/esm/instrument.js
var global3 = getGlobalObject();
var handlers = {};
var instrumented = {};
function instrument(type) {
  if (instrumented[type]) {
    return;
  }
  instrumented[type] = true;
  switch (type) {
    case "console":
      instrumentConsole();
      break;
    case "dom":
      instrumentDOM();
      break;
    case "xhr":
      instrumentXHR();
      break;
    case "fetch":
      instrumentFetch();
      break;
    case "history":
      instrumentHistory();
      break;
    case "error":
      instrumentError();
      break;
    case "unhandledrejection":
      instrumentUnhandledRejection();
      break;
    default:
      IS_DEBUG_BUILD && logger.warn("unknown instrumentation type:", type);
      return;
  }
}
function addInstrumentationHandler(type, callback) {
  handlers[type] = handlers[type] || [];
  handlers[type].push(callback);
  instrument(type);
}
function triggerHandlers(type, data) {
  var e_1, _a;
  if (!type || !handlers[type]) {
    return;
  }
  try {
    for (var _b = __values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
      var handler = _c.value;
      try {
        handler(data);
      } catch (e) {
        IS_DEBUG_BUILD && logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + getFunctionName(handler) + "\nError:", e);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
}
function instrumentConsole() {
  if (!("console" in global3)) {
    return;
  }
  CONSOLE_LEVELS.forEach(function(level) {
    if (!(level in global3.console)) {
      return;
    }
    fill(global3.console, level, function(originalConsoleMethod) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        triggerHandlers("console", { args, level });
        if (originalConsoleMethod) {
          originalConsoleMethod.apply(global3.console, args);
        }
      };
    });
  });
}
function instrumentFetch() {
  if (!supportsNativeFetch()) {
    return;
  }
  fill(global3, "fetch", function(originalFetch) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var handlerData = {
        args,
        fetchData: {
          method: getFetchMethod(args),
          url: getFetchUrl(args)
        },
        startTimestamp: Date.now()
      };
      triggerHandlers("fetch", __assign({}, handlerData));
      return originalFetch.apply(global3, args).then(function(response) {
        triggerHandlers("fetch", __assign(__assign({}, handlerData), { endTimestamp: Date.now(), response }));
        return response;
      }, function(error) {
        triggerHandlers("fetch", __assign(__assign({}, handlerData), { endTimestamp: Date.now(), error }));
        throw error;
      });
    };
  });
}
function getFetchMethod(fetchArgs) {
  if (fetchArgs === void 0) {
    fetchArgs = [];
  }
  if ("Request" in global3 && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
    return String(fetchArgs[0].method).toUpperCase();
  }
  if (fetchArgs[1] && fetchArgs[1].method) {
    return String(fetchArgs[1].method).toUpperCase();
  }
  return "GET";
}
function getFetchUrl(fetchArgs) {
  if (fetchArgs === void 0) {
    fetchArgs = [];
  }
  if (typeof fetchArgs[0] === "string") {
    return fetchArgs[0];
  }
  if ("Request" in global3 && isInstanceOf(fetchArgs[0], Request)) {
    return fetchArgs[0].url;
  }
  return String(fetchArgs[0]);
}
function instrumentXHR() {
  if (!("XMLHttpRequest" in global3)) {
    return;
  }
  var xhrproto = XMLHttpRequest.prototype;
  fill(xhrproto, "open", function(originalOpen) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var xhr = this;
      var url = args[1];
      var xhrInfo = xhr.__sentry_xhr__ = {
        method: isString(args[0]) ? args[0].toUpperCase() : args[0],
        url: args[1]
      };
      if (isString(url) && xhrInfo.method === "POST" && url.match(/sentry_key/)) {
        xhr.__sentry_own_request__ = true;
      }
      var onreadystatechangeHandler = function() {
        if (xhr.readyState === 4) {
          try {
            xhrInfo.status_code = xhr.status;
          } catch (e) {
          }
          triggerHandlers("xhr", {
            args,
            endTimestamp: Date.now(),
            startTimestamp: Date.now(),
            xhr
          });
        }
      };
      if ("onreadystatechange" in xhr && typeof xhr.onreadystatechange === "function") {
        fill(xhr, "onreadystatechange", function(original) {
          return function() {
            var readyStateArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              readyStateArgs[_i2] = arguments[_i2];
            }
            onreadystatechangeHandler();
            return original.apply(xhr, readyStateArgs);
          };
        });
      } else {
        xhr.addEventListener("readystatechange", onreadystatechangeHandler);
      }
      return originalOpen.apply(xhr, args);
    };
  });
  fill(xhrproto, "send", function(originalSend) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.__sentry_xhr__ && args[0] !== void 0) {
        this.__sentry_xhr__.body = args[0];
      }
      triggerHandlers("xhr", {
        args,
        startTimestamp: Date.now(),
        xhr: this
      });
      return originalSend.apply(this, args);
    };
  });
}
var lastHref;
function instrumentHistory() {
  if (!supportsHistory()) {
    return;
  }
  var oldOnPopState = global3.onpopstate;
  global3.onpopstate = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var to = global3.location.href;
    var from = lastHref;
    lastHref = to;
    triggerHandlers("history", {
      from,
      to
    });
    if (oldOnPopState) {
      try {
        return oldOnPopState.apply(this, args);
      } catch (_oO) {
      }
    }
  };
  function historyReplacementFunction(originalHistoryFunction) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var url = args.length > 2 ? args[2] : void 0;
      if (url) {
        var from = lastHref;
        var to = String(url);
        lastHref = to;
        triggerHandlers("history", {
          from,
          to
        });
      }
      return originalHistoryFunction.apply(this, args);
    };
  }
  fill(global3.history, "pushState", historyReplacementFunction);
  fill(global3.history, "replaceState", historyReplacementFunction);
}
var debounceDuration = 1e3;
var debounceTimerID;
var lastCapturedEvent;
function shouldShortcircuitPreviousDebounce(previous, current) {
  if (!previous) {
    return true;
  }
  if (previous.type !== current.type) {
    return true;
  }
  try {
    if (previous.target !== current.target) {
      return true;
    }
  } catch (e) {
  }
  return false;
}
function shouldSkipDOMEvent(event) {
  if (event.type !== "keypress") {
    return false;
  }
  try {
    var target = event.target;
    if (!target || !target.tagName) {
      return true;
    }
    if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
      return false;
    }
  } catch (e) {
  }
  return true;
}
function makeDOMEventHandler(handler, globalListener) {
  if (globalListener === void 0) {
    globalListener = false;
  }
  return function(event) {
    if (!event || lastCapturedEvent === event) {
      return;
    }
    if (shouldSkipDOMEvent(event)) {
      return;
    }
    var name = event.type === "keypress" ? "input" : event.type;
    if (debounceTimerID === void 0) {
      handler({
        event,
        name,
        global: globalListener
      });
      lastCapturedEvent = event;
    } else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
      handler({
        event,
        name,
        global: globalListener
      });
      lastCapturedEvent = event;
    }
    clearTimeout(debounceTimerID);
    debounceTimerID = global3.setTimeout(function() {
      debounceTimerID = void 0;
    }, debounceDuration);
  };
}
function instrumentDOM() {
  if (!("document" in global3)) {
    return;
  }
  var triggerDOMHandler = triggerHandlers.bind(null, "dom");
  var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
  global3.document.addEventListener("click", globalDOMEventHandler, false);
  global3.document.addEventListener("keypress", globalDOMEventHandler, false);
  ["EventTarget", "Node"].forEach(function(target) {
    var proto = global3[target] && global3[target].prototype;
    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
      return;
    }
    fill(proto, "addEventListener", function(originalAddEventListener) {
      return function(type, listener, options) {
        if (type === "click" || type == "keypress") {
          try {
            var el = this;
            var handlers_1 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
            var handlerForType = handlers_1[type] = handlers_1[type] || { refCount: 0 };
            if (!handlerForType.handler) {
              var handler = makeDOMEventHandler(triggerDOMHandler);
              handlerForType.handler = handler;
              originalAddEventListener.call(this, type, handler, options);
            }
            handlerForType.refCount += 1;
          } catch (e) {
          }
        }
        return originalAddEventListener.call(this, type, listener, options);
      };
    });
    fill(proto, "removeEventListener", function(originalRemoveEventListener) {
      return function(type, listener, options) {
        if (type === "click" || type == "keypress") {
          try {
            var el = this;
            var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
            var handlerForType = handlers_2[type];
            if (handlerForType) {
              handlerForType.refCount -= 1;
              if (handlerForType.refCount <= 0) {
                originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                handlerForType.handler = void 0;
                delete handlers_2[type];
              }
              if (Object.keys(handlers_2).length === 0) {
                delete el.__sentry_instrumentation_handlers__;
              }
            }
          } catch (e) {
          }
        }
        return originalRemoveEventListener.call(this, type, listener, options);
      };
    });
  });
}
var _oldOnErrorHandler = null;
function instrumentError() {
  _oldOnErrorHandler = global3.onerror;
  global3.onerror = function(msg, url, line, column, error) {
    triggerHandlers("error", {
      column,
      error,
      line,
      msg,
      url
    });
    if (_oldOnErrorHandler) {
      return _oldOnErrorHandler.apply(this, arguments);
    }
    return false;
  };
}
var _oldOnUnhandledRejectionHandler = null;
function instrumentUnhandledRejection() {
  _oldOnUnhandledRejectionHandler = global3.onunhandledrejection;
  global3.onunhandledrejection = function(e) {
    triggerHandlers("unhandledrejection", e);
    if (_oldOnUnhandledRejectionHandler) {
      return _oldOnUnhandledRejectionHandler.apply(this, arguments);
    }
    return true;
  };
}

// node_modules/@sentry/utils/esm/memo.js
function memoBuilder() {
  var hasWeakSet = typeof WeakSet === "function";
  var inner = hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];
  function memoize(obj) {
    if (hasWeakSet) {
      if (inner.has(obj)) {
        return true;
      }
      inner.add(obj);
      return false;
    }
    for (var i = 0; i < inner.length; i++) {
      var value = inner[i];
      if (value === obj) {
        return true;
      }
    }
    inner.push(obj);
    return false;
  }
  function unmemoize(obj) {
    if (hasWeakSet) {
      inner.delete(obj);
    } else {
      for (var i = 0; i < inner.length; i++) {
        if (inner[i] === obj) {
          inner.splice(i, 1);
          break;
        }
      }
    }
  }
  return [memoize, unmemoize];
}

// node_modules/@sentry/utils/esm/normalize.js
function normalize(input, depth, maxProperties) {
  if (depth === void 0) {
    depth = Infinity;
  }
  if (maxProperties === void 0) {
    maxProperties = Infinity;
  }
  try {
    return visit("", input, depth, maxProperties);
  } catch (err) {
    return { ERROR: "**non-serializable** (" + err + ")" };
  }
}
function normalizeToSize(object, depth, maxSize) {
  if (depth === void 0) {
    depth = 3;
  }
  if (maxSize === void 0) {
    maxSize = 100 * 1024;
  }
  var normalized = normalize(object, depth);
  if (jsonSize(normalized) > maxSize) {
    return normalizeToSize(object, depth - 1, maxSize);
  }
  return normalized;
}
function visit(key, value, depth, maxProperties, memo) {
  if (depth === void 0) {
    depth = Infinity;
  }
  if (maxProperties === void 0) {
    maxProperties = Infinity;
  }
  if (memo === void 0) {
    memo = memoBuilder();
  }
  var _a = __read(memo, 2), memoize = _a[0], unmemoize = _a[1];
  var valueWithToJSON = value;
  if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
    try {
      return valueWithToJSON.toJSON();
    } catch (err) {
    }
  }
  if (value === null || ["number", "boolean", "string"].includes(typeof value) && !isNaN2(value)) {
    return value;
  }
  var stringified = stringifyValue(key, value);
  if (!stringified.startsWith("[object ")) {
    return stringified;
  }
  if (depth === 0) {
    return stringified.replace("object ", "");
  }
  if (memoize(value)) {
    return "[Circular ~]";
  }
  var normalized = Array.isArray(value) ? [] : {};
  var numAdded = 0;
  var visitable = isError(value) || isEvent(value) ? convertToPlainObject(value) : value;
  for (var visitKey in visitable) {
    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
      continue;
    }
    if (numAdded >= maxProperties) {
      normalized[visitKey] = "[MaxProperties ~]";
      break;
    }
    var visitValue = visitable[visitKey];
    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);
    numAdded += 1;
  }
  unmemoize(value);
  return normalized;
}
function stringifyValue(key, value) {
  try {
    if (key === "domain" && value && typeof value === "object" && value._events) {
      return "[Domain]";
    }
    if (key === "domainEmitter") {
      return "[DomainEmitter]";
    }
    if (typeof global !== "undefined" && value === global) {
      return "[Global]";
    }
    if (typeof window !== "undefined" && value === window) {
      return "[Window]";
    }
    if (typeof document !== "undefined" && value === document) {
      return "[Document]";
    }
    if (isSyntheticEvent(value)) {
      return "[SyntheticEvent]";
    }
    if (typeof value === "number" && value !== value) {
      return "[NaN]";
    }
    if (value === void 0) {
      return "[undefined]";
    }
    if (typeof value === "function") {
      return "[Function: " + getFunctionName(value) + "]";
    }
    if (typeof value === "symbol") {
      return "[" + String(value) + "]";
    }
    if (typeof value === "bigint") {
      return "[BigInt: " + String(value) + "]";
    }
    return "[object " + Object.getPrototypeOf(value).constructor.name + "]";
  } catch (err) {
    return "**non-serializable** (" + err + ")";
  }
}
function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}
function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}

// node_modules/@sentry/utils/esm/syncpromise.js
function resolvedSyncPromise(value) {
  return new SyncPromise(function(resolve) {
    resolve(value);
  });
}
function rejectedSyncPromise(reason) {
  return new SyncPromise(function(_, reject) {
    reject(reason);
  });
}
var SyncPromise = function() {
  function SyncPromise2(executor) {
    var _this = this;
    this._state = 0;
    this._handlers = [];
    this._resolve = function(value) {
      _this._setResult(1, value);
    };
    this._reject = function(reason) {
      _this._setResult(2, reason);
    };
    this._setResult = function(state, value) {
      if (_this._state !== 0) {
        return;
      }
      if (isThenable(value)) {
        void value.then(_this._resolve, _this._reject);
        return;
      }
      _this._state = state;
      _this._value = value;
      _this._executeHandlers();
    };
    this._executeHandlers = function() {
      if (_this._state === 0) {
        return;
      }
      var cachedHandlers = _this._handlers.slice();
      _this._handlers = [];
      cachedHandlers.forEach(function(handler) {
        if (handler[0]) {
          return;
        }
        if (_this._state === 1) {
          handler[1](_this._value);
        }
        if (_this._state === 2) {
          handler[2](_this._value);
        }
        handler[0] = true;
      });
    };
    try {
      executor(this._resolve, this._reject);
    } catch (e) {
      this._reject(e);
    }
  }
  SyncPromise2.prototype.then = function(onfulfilled, onrejected) {
    var _this = this;
    return new SyncPromise2(function(resolve, reject) {
      _this._handlers.push([
        false,
        function(result) {
          if (!onfulfilled) {
            resolve(result);
          } else {
            try {
              resolve(onfulfilled(result));
            } catch (e) {
              reject(e);
            }
          }
        },
        function(reason) {
          if (!onrejected) {
            reject(reason);
          } else {
            try {
              resolve(onrejected(reason));
            } catch (e) {
              reject(e);
            }
          }
        }
      ]);
      _this._executeHandlers();
    });
  };
  SyncPromise2.prototype.catch = function(onrejected) {
    return this.then(function(val) {
      return val;
    }, onrejected);
  };
  SyncPromise2.prototype.finally = function(onfinally) {
    var _this = this;
    return new SyncPromise2(function(resolve, reject) {
      var val;
      var isRejected;
      return _this.then(function(value) {
        isRejected = false;
        val = value;
        if (onfinally) {
          onfinally();
        }
      }, function(reason) {
        isRejected = true;
        val = reason;
        if (onfinally) {
          onfinally();
        }
      }).then(function() {
        if (isRejected) {
          reject(val);
          return;
        }
        resolve(val);
      });
    });
  };
  return SyncPromise2;
}();

// node_modules/@sentry/utils/esm/promisebuffer.js
function makePromiseBuffer(limit) {
  var buffer = [];
  function isReady() {
    return limit === void 0 || buffer.length < limit;
  }
  function remove(task) {
    return buffer.splice(buffer.indexOf(task), 1)[0];
  }
  function add(taskProducer) {
    if (!isReady()) {
      return rejectedSyncPromise(new SentryError("Not adding Promise due to buffer limit reached."));
    }
    var task = taskProducer();
    if (buffer.indexOf(task) === -1) {
      buffer.push(task);
    }
    void task.then(function() {
      return remove(task);
    }).then(null, function() {
      return remove(task).then(null, function() {
      });
    });
    return task;
  }
  function drain(timeout) {
    return new SyncPromise(function(resolve, reject) {
      var counter = buffer.length;
      if (!counter) {
        return resolve(true);
      }
      var capturedSetTimeout = setTimeout(function() {
        if (timeout && timeout > 0) {
          resolve(false);
        }
      }, timeout);
      buffer.forEach(function(item) {
        void resolvedSyncPromise(item).then(function() {
          if (!--counter) {
            clearTimeout(capturedSetTimeout);
            resolve(true);
          }
        }, reject);
      });
    });
  }
  return {
    $: buffer,
    add,
    drain
  };
}

// node_modules/@sentry/utils/esm/severity.js
function isSupportedSeverity(level) {
  return SeverityLevels2.indexOf(level) !== -1;
}
function severityFromString(level) {
  if (level === "warn")
    return Severity.Warning;
  if (isSupportedSeverity(level)) {
    return level;
  }
  return Severity.Log;
}

// node_modules/@sentry/utils/esm/status.js
function eventStatusFromHttpCode(code) {
  if (code >= 200 && code < 300) {
    return "success";
  }
  if (code === 429) {
    return "rate_limit";
  }
  if (code >= 400 && code < 500) {
    return "invalid";
  }
  if (code >= 500) {
    return "failed";
  }
  return "unknown";
}

// node_modules/@sentry/utils/esm/time.js
var dateTimestampSource = {
  nowSeconds: function() {
    return Date.now() / 1e3;
  }
};
function getBrowserPerformance() {
  var performance = getGlobalObject().performance;
  if (!performance || !performance.now) {
    return void 0;
  }
  var timeOrigin = Date.now() - performance.now();
  return {
    now: function() {
      return performance.now();
    },
    timeOrigin
  };
}
function getNodePerformance() {
  try {
    var perfHooks = dynamicRequire(module, "perf_hooks");
    return perfHooks.performance;
  } catch (_) {
    return void 0;
  }
}
var platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
  nowSeconds: function() {
    return (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3;
  }
};
var dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
var timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
var timestampWithMs = timestampInSeconds;
var _browserPerformanceTimeOriginMode;
var browserPerformanceTimeOrigin = function() {
  var performance = getGlobalObject().performance;
  if (!performance || !performance.now) {
    _browserPerformanceTimeOriginMode = "none";
    return void 0;
  }
  var threshold = 3600 * 1e3;
  var performanceNow = performance.now();
  var dateNow = Date.now();
  var timeOriginDelta = performance.timeOrigin ? Math.abs(performance.timeOrigin + performanceNow - dateNow) : threshold;
  var timeOriginIsReliable = timeOriginDelta < threshold;
  var navigationStart = performance.timing && performance.timing.navigationStart;
  var hasNavigationStart = typeof navigationStart === "number";
  var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
  var navigationStartIsReliable = navigationStartDelta < threshold;
  if (timeOriginIsReliable || navigationStartIsReliable) {
    if (timeOriginDelta <= navigationStartDelta) {
      _browserPerformanceTimeOriginMode = "timeOrigin";
      return performance.timeOrigin;
    } else {
      _browserPerformanceTimeOriginMode = "navigationStart";
      return navigationStart;
    }
  }
  _browserPerformanceTimeOriginMode = "dateNow";
  return dateNow;
}();

// node_modules/@sentry/utils/esm/envelope.js
function createEnvelope(headers, items) {
  if (items === void 0) {
    items = [];
  }
  return [headers, items];
}
function getEnvelopeType(envelope) {
  var _a = __read(envelope, 2), _b = __read(_a[1], 1), _c = __read(_b[0], 1), firstItemHeader = _c[0];
  return firstItemHeader.type;
}
function serializeEnvelope(envelope) {
  var _a = __read(envelope, 2), headers = _a[0], items = _a[1];
  var serializedHeaders = JSON.stringify(headers);
  return items.reduce(function(acc, item) {
    var _a2 = __read(item, 2), itemHeaders = _a2[0], payload = _a2[1];
    var serializedPayload = isPrimitive(payload) ? String(payload) : JSON.stringify(payload);
    return acc + "\n" + JSON.stringify(itemHeaders) + "\n" + serializedPayload;
  }, serializedHeaders);
}

// node_modules/@sentry/utils/esm/clientreport.js
function createClientReportEnvelope(discarded_events, dsn, timestamp) {
  var clientReportItem = [
    { type: "client_report" },
    {
      timestamp: timestamp || dateTimestampInSeconds(),
      discarded_events
    }
  ];
  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
}

// node_modules/@sentry/utils/esm/ratelimit.js
var DEFAULT_RETRY_AFTER = 60 * 1e3;
function parseRetryAfterHeader(header, now) {
  if (now === void 0) {
    now = Date.now();
  }
  var headerDelay = parseInt("" + header, 10);
  if (!isNaN(headerDelay)) {
    return headerDelay * 1e3;
  }
  var headerDate = Date.parse("" + header);
  if (!isNaN(headerDate)) {
    return headerDate - now;
  }
  return DEFAULT_RETRY_AFTER;
}
function disabledUntil(limits, category) {
  return limits[category] || limits.all || 0;
}
function isRateLimited(limits, category, now) {
  if (now === void 0) {
    now = Date.now();
  }
  return disabledUntil(limits, category) > now;
}
function updateRateLimits(limits, headers, now) {
  var e_1, _a, e_2, _b;
  if (now === void 0) {
    now = Date.now();
  }
  var updatedRateLimits = __assign({}, limits);
  var rateLimitHeader = headers["x-sentry-rate-limits"];
  var retryAfterHeader = headers["retry-after"];
  if (rateLimitHeader) {
    try {
      for (var _c = __values(rateLimitHeader.trim().split(",")), _d = _c.next(); !_d.done; _d = _c.next()) {
        var limit = _d.value;
        var parameters = limit.split(":", 2);
        var headerDelay = parseInt(parameters[0], 10);
        var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
        if (!parameters[1]) {
          updatedRateLimits.all = now + delay;
        } else {
          try {
            for (var _e = (e_2 = void 0, __values(parameters[1].split(";"))), _f = _e.next(); !_f.done; _f = _e.next()) {
              var category = _f.value;
              updatedRateLimits[category] = now + delay;
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_f && !_f.done && (_b = _e.return))
                _b.call(_e);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a = _c.return))
          _a.call(_c);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  } else if (retryAfterHeader) {
    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
  }
  return updatedRateLimits;
}

// node_modules/@sentry/hub/esm/scope.js
var MAX_BREADCRUMBS = 100;
var Scope = function() {
  function Scope2() {
    this._notifyingListeners = false;
    this._scopeListeners = [];
    this._eventProcessors = [];
    this._breadcrumbs = [];
    this._user = {};
    this._tags = {};
    this._extra = {};
    this._contexts = {};
    this._sdkProcessingMetadata = {};
  }
  Scope2.clone = function(scope) {
    var newScope = new Scope2();
    if (scope) {
      newScope._breadcrumbs = __spread(scope._breadcrumbs);
      newScope._tags = __assign({}, scope._tags);
      newScope._extra = __assign({}, scope._extra);
      newScope._contexts = __assign({}, scope._contexts);
      newScope._user = scope._user;
      newScope._level = scope._level;
      newScope._span = scope._span;
      newScope._session = scope._session;
      newScope._transactionName = scope._transactionName;
      newScope._fingerprint = scope._fingerprint;
      newScope._eventProcessors = __spread(scope._eventProcessors);
      newScope._requestSession = scope._requestSession;
    }
    return newScope;
  };
  Scope2.prototype.addScopeListener = function(callback) {
    this._scopeListeners.push(callback);
  };
  Scope2.prototype.addEventProcessor = function(callback) {
    this._eventProcessors.push(callback);
    return this;
  };
  Scope2.prototype.setUser = function(user) {
    this._user = user || {};
    if (this._session) {
      this._session.update({ user });
    }
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.getUser = function() {
    return this._user;
  };
  Scope2.prototype.getRequestSession = function() {
    return this._requestSession;
  };
  Scope2.prototype.setRequestSession = function(requestSession) {
    this._requestSession = requestSession;
    return this;
  };
  Scope2.prototype.setTags = function(tags) {
    this._tags = __assign(__assign({}, this._tags), tags);
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.setTag = function(key, value) {
    var _a;
    this._tags = __assign(__assign({}, this._tags), (_a = {}, _a[key] = value, _a));
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.setExtras = function(extras) {
    this._extra = __assign(__assign({}, this._extra), extras);
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.setExtra = function(key, extra) {
    var _a;
    this._extra = __assign(__assign({}, this._extra), (_a = {}, _a[key] = extra, _a));
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.setFingerprint = function(fingerprint) {
    this._fingerprint = fingerprint;
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.setLevel = function(level) {
    this._level = level;
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.setTransactionName = function(name) {
    this._transactionName = name;
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.setTransaction = function(name) {
    return this.setTransactionName(name);
  };
  Scope2.prototype.setContext = function(key, context) {
    var _a;
    if (context === null) {
      delete this._contexts[key];
    } else {
      this._contexts = __assign(__assign({}, this._contexts), (_a = {}, _a[key] = context, _a));
    }
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.setSpan = function(span) {
    this._span = span;
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.getSpan = function() {
    return this._span;
  };
  Scope2.prototype.getTransaction = function() {
    var span = this.getSpan();
    return span && span.transaction;
  };
  Scope2.prototype.setSession = function(session) {
    if (!session) {
      delete this._session;
    } else {
      this._session = session;
    }
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.getSession = function() {
    return this._session;
  };
  Scope2.prototype.update = function(captureContext) {
    if (!captureContext) {
      return this;
    }
    if (typeof captureContext === "function") {
      var updatedScope = captureContext(this);
      return updatedScope instanceof Scope2 ? updatedScope : this;
    }
    if (captureContext instanceof Scope2) {
      this._tags = __assign(__assign({}, this._tags), captureContext._tags);
      this._extra = __assign(__assign({}, this._extra), captureContext._extra);
      this._contexts = __assign(__assign({}, this._contexts), captureContext._contexts);
      if (captureContext._user && Object.keys(captureContext._user).length) {
        this._user = captureContext._user;
      }
      if (captureContext._level) {
        this._level = captureContext._level;
      }
      if (captureContext._fingerprint) {
        this._fingerprint = captureContext._fingerprint;
      }
      if (captureContext._requestSession) {
        this._requestSession = captureContext._requestSession;
      }
    } else if (isPlainObject(captureContext)) {
      captureContext = captureContext;
      this._tags = __assign(__assign({}, this._tags), captureContext.tags);
      this._extra = __assign(__assign({}, this._extra), captureContext.extra);
      this._contexts = __assign(__assign({}, this._contexts), captureContext.contexts);
      if (captureContext.user) {
        this._user = captureContext.user;
      }
      if (captureContext.level) {
        this._level = captureContext.level;
      }
      if (captureContext.fingerprint) {
        this._fingerprint = captureContext.fingerprint;
      }
      if (captureContext.requestSession) {
        this._requestSession = captureContext.requestSession;
      }
    }
    return this;
  };
  Scope2.prototype.clear = function() {
    this._breadcrumbs = [];
    this._tags = {};
    this._extra = {};
    this._user = {};
    this._contexts = {};
    this._level = void 0;
    this._transactionName = void 0;
    this._fingerprint = void 0;
    this._requestSession = void 0;
    this._span = void 0;
    this._session = void 0;
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.addBreadcrumb = function(breadcrumb, maxBreadcrumbs) {
    var maxCrumbs = typeof maxBreadcrumbs === "number" ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
    if (maxCrumbs <= 0) {
      return this;
    }
    var mergedBreadcrumb = __assign({ timestamp: dateTimestampInSeconds() }, breadcrumb);
    this._breadcrumbs = __spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.clearBreadcrumbs = function() {
    this._breadcrumbs = [];
    this._notifyScopeListeners();
    return this;
  };
  Scope2.prototype.applyToEvent = function(event, hint) {
    if (this._extra && Object.keys(this._extra).length) {
      event.extra = __assign(__assign({}, this._extra), event.extra);
    }
    if (this._tags && Object.keys(this._tags).length) {
      event.tags = __assign(__assign({}, this._tags), event.tags);
    }
    if (this._user && Object.keys(this._user).length) {
      event.user = __assign(__assign({}, this._user), event.user);
    }
    if (this._contexts && Object.keys(this._contexts).length) {
      event.contexts = __assign(__assign({}, this._contexts), event.contexts);
    }
    if (this._level) {
      event.level = this._level;
    }
    if (this._transactionName) {
      event.transaction = this._transactionName;
    }
    if (this._span) {
      event.contexts = __assign({ trace: this._span.getTraceContext() }, event.contexts);
      var transactionName = this._span.transaction && this._span.transaction.name;
      if (transactionName) {
        event.tags = __assign({ transaction: transactionName }, event.tags);
      }
    }
    this._applyFingerprint(event);
    event.breadcrumbs = __spread(event.breadcrumbs || [], this._breadcrumbs);
    event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : void 0;
    event.sdkProcessingMetadata = this._sdkProcessingMetadata;
    return this._notifyEventProcessors(__spread(getGlobalEventProcessors(), this._eventProcessors), event, hint);
  };
  Scope2.prototype.setSDKProcessingMetadata = function(newData) {
    this._sdkProcessingMetadata = __assign(__assign({}, this._sdkProcessingMetadata), newData);
    return this;
  };
  Scope2.prototype._notifyEventProcessors = function(processors, event, hint, index) {
    var _this = this;
    if (index === void 0) {
      index = 0;
    }
    return new SyncPromise(function(resolve, reject) {
      var processor = processors[index];
      if (event === null || typeof processor !== "function") {
        resolve(event);
      } else {
        var result = processor(__assign({}, event), hint);
        if (isThenable(result)) {
          void result.then(function(final) {
            return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve);
          }).then(null, reject);
        } else {
          void _this._notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
        }
      }
    });
  };
  Scope2.prototype._notifyScopeListeners = function() {
    var _this = this;
    if (!this._notifyingListeners) {
      this._notifyingListeners = true;
      this._scopeListeners.forEach(function(callback) {
        callback(_this);
      });
      this._notifyingListeners = false;
    }
  };
  Scope2.prototype._applyFingerprint = function(event) {
    event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
    if (this._fingerprint) {
      event.fingerprint = event.fingerprint.concat(this._fingerprint);
    }
    if (event.fingerprint && !event.fingerprint.length) {
      delete event.fingerprint;
    }
  };
  return Scope2;
}();
function getGlobalEventProcessors() {
  return getGlobalSingleton("globalEventProcessors", function() {
    return [];
  });
}
function addGlobalEventProcessor(callback) {
  getGlobalEventProcessors().push(callback);
}

// node_modules/@sentry/hub/esm/session.js
var Session = function() {
  function Session2(context) {
    this.errors = 0;
    this.sid = uuid4();
    this.duration = 0;
    this.status = "ok";
    this.init = true;
    this.ignoreDuration = false;
    var startingTime = timestampInSeconds();
    this.timestamp = startingTime;
    this.started = startingTime;
    if (context) {
      this.update(context);
    }
  }
  Session2.prototype.update = function(context) {
    if (context === void 0) {
      context = {};
    }
    if (context.user) {
      if (!this.ipAddress && context.user.ip_address) {
        this.ipAddress = context.user.ip_address;
      }
      if (!this.did && !context.did) {
        this.did = context.user.id || context.user.email || context.user.username;
      }
    }
    this.timestamp = context.timestamp || timestampInSeconds();
    if (context.ignoreDuration) {
      this.ignoreDuration = context.ignoreDuration;
    }
    if (context.sid) {
      this.sid = context.sid.length === 32 ? context.sid : uuid4();
    }
    if (context.init !== void 0) {
      this.init = context.init;
    }
    if (!this.did && context.did) {
      this.did = "" + context.did;
    }
    if (typeof context.started === "number") {
      this.started = context.started;
    }
    if (this.ignoreDuration) {
      this.duration = void 0;
    } else if (typeof context.duration === "number") {
      this.duration = context.duration;
    } else {
      var duration = this.timestamp - this.started;
      this.duration = duration >= 0 ? duration : 0;
    }
    if (context.release) {
      this.release = context.release;
    }
    if (context.environment) {
      this.environment = context.environment;
    }
    if (!this.ipAddress && context.ipAddress) {
      this.ipAddress = context.ipAddress;
    }
    if (!this.userAgent && context.userAgent) {
      this.userAgent = context.userAgent;
    }
    if (typeof context.errors === "number") {
      this.errors = context.errors;
    }
    if (context.status) {
      this.status = context.status;
    }
  };
  Session2.prototype.close = function(status) {
    if (status) {
      this.update({ status });
    } else if (this.status === "ok") {
      this.update({ status: "exited" });
    } else {
      this.update();
    }
  };
  Session2.prototype.toJSON = function() {
    return dropUndefinedKeys({
      sid: "" + this.sid,
      init: this.init,
      started: new Date(this.started * 1e3).toISOString(),
      timestamp: new Date(this.timestamp * 1e3).toISOString(),
      status: this.status,
      errors: this.errors,
      did: typeof this.did === "number" || typeof this.did === "string" ? "" + this.did : void 0,
      duration: this.duration,
      attrs: {
        release: this.release,
        environment: this.environment,
        ip_address: this.ipAddress,
        user_agent: this.userAgent
      }
    });
  };
  return Session2;
}();

// node_modules/@sentry/hub/esm/flags.js
var IS_DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

// node_modules/@sentry/hub/esm/hub.js
var API_VERSION = 4;
var DEFAULT_BREADCRUMBS = 100;
var Hub = function() {
  function Hub2(client, scope, _version) {
    if (scope === void 0) {
      scope = new Scope();
    }
    if (_version === void 0) {
      _version = API_VERSION;
    }
    this._version = _version;
    this._stack = [{}];
    this.getStackTop().scope = scope;
    if (client) {
      this.bindClient(client);
    }
  }
  Hub2.prototype.isOlderThan = function(version) {
    return this._version < version;
  };
  Hub2.prototype.bindClient = function(client) {
    var top = this.getStackTop();
    top.client = client;
    if (client && client.setupIntegrations) {
      client.setupIntegrations();
    }
  };
  Hub2.prototype.pushScope = function() {
    var scope = Scope.clone(this.getScope());
    this.getStack().push({
      client: this.getClient(),
      scope
    });
    return scope;
  };
  Hub2.prototype.popScope = function() {
    if (this.getStack().length <= 1)
      return false;
    return !!this.getStack().pop();
  };
  Hub2.prototype.withScope = function(callback) {
    var scope = this.pushScope();
    try {
      callback(scope);
    } finally {
      this.popScope();
    }
  };
  Hub2.prototype.getClient = function() {
    return this.getStackTop().client;
  };
  Hub2.prototype.getScope = function() {
    return this.getStackTop().scope;
  };
  Hub2.prototype.getStack = function() {
    return this._stack;
  };
  Hub2.prototype.getStackTop = function() {
    return this._stack[this._stack.length - 1];
  };
  Hub2.prototype.captureException = function(exception, hint) {
    var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
    var finalHint = hint;
    if (!hint) {
      var syntheticException = void 0;
      try {
        throw new Error("Sentry syntheticException");
      } catch (exception2) {
        syntheticException = exception2;
      }
      finalHint = {
        originalException: exception,
        syntheticException
      };
    }
    this._invokeClient("captureException", exception, __assign(__assign({}, finalHint), { event_id: eventId }));
    return eventId;
  };
  Hub2.prototype.captureMessage = function(message, level, hint) {
    var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
    var finalHint = hint;
    if (!hint) {
      var syntheticException = void 0;
      try {
        throw new Error(message);
      } catch (exception) {
        syntheticException = exception;
      }
      finalHint = {
        originalException: message,
        syntheticException
      };
    }
    this._invokeClient("captureMessage", message, level, __assign(__assign({}, finalHint), { event_id: eventId }));
    return eventId;
  };
  Hub2.prototype.captureEvent = function(event, hint) {
    var eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (event.type !== "transaction") {
      this._lastEventId = eventId;
    }
    this._invokeClient("captureEvent", event, __assign(__assign({}, hint), { event_id: eventId }));
    return eventId;
  };
  Hub2.prototype.lastEventId = function() {
    return this._lastEventId;
  };
  Hub2.prototype.addBreadcrumb = function(breadcrumb, hint) {
    var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
    if (!scope || !client)
      return;
    var _b = client.getOptions && client.getOptions() || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
    if (maxBreadcrumbs <= 0)
      return;
    var timestamp = dateTimestampInSeconds();
    var mergedBreadcrumb = __assign({ timestamp }, breadcrumb);
    var finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(function() {
      return beforeBreadcrumb(mergedBreadcrumb, hint);
    }) : mergedBreadcrumb;
    if (finalBreadcrumb === null)
      return;
    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
  };
  Hub2.prototype.setUser = function(user) {
    var scope = this.getScope();
    if (scope)
      scope.setUser(user);
  };
  Hub2.prototype.setTags = function(tags) {
    var scope = this.getScope();
    if (scope)
      scope.setTags(tags);
  };
  Hub2.prototype.setExtras = function(extras) {
    var scope = this.getScope();
    if (scope)
      scope.setExtras(extras);
  };
  Hub2.prototype.setTag = function(key, value) {
    var scope = this.getScope();
    if (scope)
      scope.setTag(key, value);
  };
  Hub2.prototype.setExtra = function(key, extra) {
    var scope = this.getScope();
    if (scope)
      scope.setExtra(key, extra);
  };
  Hub2.prototype.setContext = function(name, context) {
    var scope = this.getScope();
    if (scope)
      scope.setContext(name, context);
  };
  Hub2.prototype.configureScope = function(callback) {
    var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
    if (scope && client) {
      callback(scope);
    }
  };
  Hub2.prototype.run = function(callback) {
    var oldHub = makeMain(this);
    try {
      callback(this);
    } finally {
      makeMain(oldHub);
    }
  };
  Hub2.prototype.getIntegration = function(integration) {
    var client = this.getClient();
    if (!client)
      return null;
    try {
      return client.getIntegration(integration);
    } catch (_oO) {
      IS_DEBUG_BUILD2 && logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
      return null;
    }
  };
  Hub2.prototype.startSpan = function(context) {
    return this._callExtensionMethod("startSpan", context);
  };
  Hub2.prototype.startTransaction = function(context, customSamplingContext) {
    return this._callExtensionMethod("startTransaction", context, customSamplingContext);
  };
  Hub2.prototype.traceHeaders = function() {
    return this._callExtensionMethod("traceHeaders");
  };
  Hub2.prototype.captureSession = function(endSession) {
    if (endSession === void 0) {
      endSession = false;
    }
    if (endSession) {
      return this.endSession();
    }
    this._sendSessionUpdate();
  };
  Hub2.prototype.endSession = function() {
    var layer = this.getStackTop();
    var scope = layer && layer.scope;
    var session = scope && scope.getSession();
    if (session) {
      session.close();
    }
    this._sendSessionUpdate();
    if (scope) {
      scope.setSession();
    }
  };
  Hub2.prototype.startSession = function(context) {
    var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
    var _b = client && client.getOptions() || {}, release = _b.release, environment = _b.environment;
    var global4 = getGlobalObject();
    var userAgent = (global4.navigator || {}).userAgent;
    var session = new Session(__assign(__assign(__assign({
      release,
      environment
    }, scope && { user: scope.getUser() }), userAgent && { userAgent }), context));
    if (scope) {
      var currentSession = scope.getSession && scope.getSession();
      if (currentSession && currentSession.status === "ok") {
        currentSession.update({ status: "exited" });
      }
      this.endSession();
      scope.setSession(session);
    }
    return session;
  };
  Hub2.prototype._sendSessionUpdate = function() {
    var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
    if (!scope)
      return;
    var session = scope.getSession && scope.getSession();
    if (session) {
      if (client && client.captureSession) {
        client.captureSession(session);
      }
    }
  };
  Hub2.prototype._invokeClient = function(method) {
    var _a;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
    if (client && client[method]) {
      (_a = client)[method].apply(_a, __spread(args, [scope]));
    }
  };
  Hub2.prototype._callExtensionMethod = function(method) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var carrier = getMainCarrier();
    var sentry = carrier.__SENTRY__;
    if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
      return sentry.extensions[method].apply(this, args);
    }
    IS_DEBUG_BUILD2 && logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
  };
  return Hub2;
}();
function getMainCarrier() {
  var carrier = getGlobalObject();
  carrier.__SENTRY__ = carrier.__SENTRY__ || {
    extensions: {},
    hub: void 0
  };
  return carrier;
}
function makeMain(hub) {
  var registry = getMainCarrier();
  var oldHub = getHubFromCarrier(registry);
  setHubOnCarrier(registry, hub);
  return oldHub;
}
function getCurrentHub() {
  var registry = getMainCarrier();
  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
    setHubOnCarrier(registry, new Hub());
  }
  if (isNodeEnv()) {
    return getHubFromActiveDomain(registry);
  }
  return getHubFromCarrier(registry);
}
function getHubFromActiveDomain(registry) {
  try {
    var sentry = getMainCarrier().__SENTRY__;
    var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
    if (!activeDomain) {
      return getHubFromCarrier(registry);
    }
    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
      var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));
    }
    return getHubFromCarrier(activeDomain);
  } catch (_Oo) {
    return getHubFromCarrier(registry);
  }
}
function hasHubOnCarrier(carrier) {
  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
}
function getHubFromCarrier(carrier) {
  return getGlobalSingleton("hub", function() {
    return new Hub();
  }, carrier);
}
function setHubOnCarrier(carrier, hub) {
  if (!carrier)
    return false;
  var __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  __SENTRY__.hub = hub;
  return true;
}

// node_modules/@sentry/hub/esm/sessionflusher.js
var SessionFlusher = function() {
  function SessionFlusher2(transport, attrs) {
    var _this = this;
    this.flushTimeout = 60;
    this._pendingAggregates = {};
    this._isEnabled = true;
    this._transport = transport;
    this._intervalId = setInterval(function() {
      return _this.flush();
    }, this.flushTimeout * 1e3);
    this._sessionAttrs = attrs;
  }
  SessionFlusher2.prototype.sendSessionAggregates = function(sessionAggregates) {
    if (!this._transport.sendSession) {
      IS_DEBUG_BUILD2 && logger.warn("Dropping session because custom transport doesn't implement sendSession");
      return;
    }
    void this._transport.sendSession(sessionAggregates).then(null, function(reason) {
      IS_DEBUG_BUILD2 && logger.error("Error while sending session:", reason);
    });
  };
  SessionFlusher2.prototype.flush = function() {
    var sessionAggregates = this.getSessionAggregates();
    if (sessionAggregates.aggregates.length === 0) {
      return;
    }
    this._pendingAggregates = {};
    this.sendSessionAggregates(sessionAggregates);
  };
  SessionFlusher2.prototype.getSessionAggregates = function() {
    var _this = this;
    var aggregates = Object.keys(this._pendingAggregates).map(function(key) {
      return _this._pendingAggregates[parseInt(key)];
    });
    var sessionAggregates = {
      attrs: this._sessionAttrs,
      aggregates
    };
    return dropUndefinedKeys(sessionAggregates);
  };
  SessionFlusher2.prototype.close = function() {
    clearInterval(this._intervalId);
    this._isEnabled = false;
    this.flush();
  };
  SessionFlusher2.prototype.incrementSessionStatusCount = function() {
    if (!this._isEnabled) {
      return;
    }
    var scope = getCurrentHub().getScope();
    var requestSession = scope && scope.getRequestSession();
    if (requestSession && requestSession.status) {
      this._incrementSessionStatusCount(requestSession.status, new Date());
      if (scope) {
        scope.setRequestSession(void 0);
      }
    }
  };
  SessionFlusher2.prototype._incrementSessionStatusCount = function(status, date) {
    var sessionStartedTrunc = new Date(date).setSeconds(0, 0);
    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
    var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
    if (!aggregationCounts.started) {
      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
    }
    switch (status) {
      case "errored":
        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
        return aggregationCounts.errored;
      case "ok":
        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
        return aggregationCounts.exited;
      default:
        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
        return aggregationCounts.crashed;
    }
  };
  return SessionFlusher2;
}();

export {
  __extends,
  __assign,
  __rest,
  __values,
  __read,
  __spread,
  Severity,
  forget,
  isNodeEnv,
  dynamicRequire,
  loadModule,
  getGlobalObject,
  isError,
  isErrorEvent,
  isDOMError,
  isDOMException,
  isString,
  isPrimitive,
  isPlainObject,
  isEvent,
  isThenable,
  isNaN2 as isNaN,
  isInstanceOf,
  htmlTreeAsString,
  getLocationHref,
  SentryError,
  dsnToString,
  makeDsn,
  logger,
  truncate,
  safeJoin,
  isMatchingPattern,
  fill,
  addNonEnumerableProperty,
  markFunctionWrapped,
  getOriginalFunction,
  urlEncode,
  extractExceptionKeysForMessage,
  dropUndefinedKeys,
  createStackParser,
  getFunctionName,
  supportsFetch,
  isNativeFetch,
  supportsReferrerPolicy,
  addInstrumentationHandler,
  uuid4,
  parseUrl,
  getEventDescription,
  addExceptionTypeValue,
  addExceptionMechanism,
  stripUrlQueryAndFragment,
  checkOrSetAlreadyCaught,
  normalize,
  normalizeToSize,
  resolvedSyncPromise,
  rejectedSyncPromise,
  SyncPromise,
  makePromiseBuffer,
  severityFromString,
  eventStatusFromHttpCode,
  dateTimestampInSeconds,
  timestampWithMs,
  browserPerformanceTimeOrigin,
  TRACEPARENT_REGEXP,
  extractTraceparentData,
  createEnvelope,
  getEnvelopeType,
  serializeEnvelope,
  createClientReportEnvelope,
  disabledUntil,
  isRateLimited,
  updateRateLimits,
  Scope,
  addGlobalEventProcessor,
  Session,
  Hub,
  getMainCarrier,
  makeMain,
  getCurrentHub,
  getHubFromCarrier
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=chunk-VGJ7RCHP.js.map

import {
  Hub,
  TRACEPARENT_REGEXP,
  __assign,
  __extends,
  __read,
  __rest,
  __spread,
  __values,
  addInstrumentationHandler,
  browserPerformanceTimeOrigin,
  dropUndefinedKeys,
  dynamicRequire,
  extractTraceparentData,
  fill,
  getCurrentHub,
  getGlobalObject,
  getMainCarrier,
  htmlTreeAsString,
  isInstanceOf,
  isMatchingPattern,
  isNaN,
  isNodeEnv,
  isThenable,
  loadModule,
  logger,
  stripUrlQueryAndFragment,
  timestampWithMs,
  uuid4
} from "./chunk-VGJ7RCHP.js";
import {
  __export
} from "./chunk-HUBM7RA2.js";

// node_modules/@sentry/tracing/esm/flags.js
var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

// node_modules/@sentry/tracing/esm/utils.js
function hasTracingEnabled(maybeOptions) {
  var client = getCurrentHub().getClient();
  var options = maybeOptions || client && client.getOptions();
  return !!options && ("tracesSampleRate" in options || "tracesSampler" in options);
}
function getActiveTransaction(maybeHub) {
  var hub = maybeHub || getCurrentHub();
  var scope = hub.getScope();
  return scope && scope.getTransaction();
}
function msToSec(time) {
  return time / 1e3;
}
function secToMs(time) {
  return time * 1e3;
}

// node_modules/@sentry/tracing/esm/errors.js
function registerErrorInstrumentation() {
  addInstrumentationHandler("error", errorCallback);
  addInstrumentationHandler("unhandledrejection", errorCallback);
}
function errorCallback() {
  var activeTransaction = getActiveTransaction();
  if (activeTransaction) {
    var status_1 = "internal_error";
    IS_DEBUG_BUILD && logger.log("[Tracing] Transaction: " + status_1 + " -> Global error occured");
    activeTransaction.setStatus(status_1);
  }
}

// node_modules/@sentry/tracing/esm/constants.js
var FINISH_REASON_TAG = "finishReason";
var IDLE_TRANSACTION_FINISH_REASONS = ["heartbeatFailed", "idleTimeout", "documentHidden"];

// node_modules/@sentry/tracing/esm/span.js
var SpanRecorder = function() {
  function SpanRecorder2(maxlen) {
    if (maxlen === void 0) {
      maxlen = 1e3;
    }
    this.spans = [];
    this._maxlen = maxlen;
  }
  SpanRecorder2.prototype.add = function(span) {
    if (this.spans.length > this._maxlen) {
      span.spanRecorder = void 0;
    } else {
      this.spans.push(span);
    }
  };
  return SpanRecorder2;
}();
var Span = function() {
  function Span2(spanContext) {
    this.traceId = uuid4();
    this.spanId = uuid4().substring(16);
    this.startTimestamp = timestampWithMs();
    this.tags = {};
    this.data = {};
    if (!spanContext) {
      return this;
    }
    if (spanContext.traceId) {
      this.traceId = spanContext.traceId;
    }
    if (spanContext.spanId) {
      this.spanId = spanContext.spanId;
    }
    if (spanContext.parentSpanId) {
      this.parentSpanId = spanContext.parentSpanId;
    }
    if ("sampled" in spanContext) {
      this.sampled = spanContext.sampled;
    }
    if (spanContext.op) {
      this.op = spanContext.op;
    }
    if (spanContext.description) {
      this.description = spanContext.description;
    }
    if (spanContext.data) {
      this.data = spanContext.data;
    }
    if (spanContext.tags) {
      this.tags = spanContext.tags;
    }
    if (spanContext.status) {
      this.status = spanContext.status;
    }
    if (spanContext.startTimestamp) {
      this.startTimestamp = spanContext.startTimestamp;
    }
    if (spanContext.endTimestamp) {
      this.endTimestamp = spanContext.endTimestamp;
    }
  }
  Span2.prototype.child = function(spanContext) {
    return this.startChild(spanContext);
  };
  Span2.prototype.startChild = function(spanContext) {
    var childSpan = new Span2(__assign(__assign({}, spanContext), { parentSpanId: this.spanId, sampled: this.sampled, traceId: this.traceId }));
    childSpan.spanRecorder = this.spanRecorder;
    if (childSpan.spanRecorder) {
      childSpan.spanRecorder.add(childSpan);
    }
    childSpan.transaction = this.transaction;
    return childSpan;
  };
  Span2.prototype.setTag = function(key, value) {
    var _a;
    this.tags = __assign(__assign({}, this.tags), (_a = {}, _a[key] = value, _a));
    return this;
  };
  Span2.prototype.setData = function(key, value) {
    var _a;
    this.data = __assign(__assign({}, this.data), (_a = {}, _a[key] = value, _a));
    return this;
  };
  Span2.prototype.setStatus = function(value) {
    this.status = value;
    return this;
  };
  Span2.prototype.setHttpStatus = function(httpStatus) {
    this.setTag("http.status_code", String(httpStatus));
    var spanStatus = spanStatusfromHttpCode(httpStatus);
    if (spanStatus !== "unknown_error") {
      this.setStatus(spanStatus);
    }
    return this;
  };
  Span2.prototype.isSuccess = function() {
    return this.status === "ok";
  };
  Span2.prototype.finish = function(endTimestamp) {
    this.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : timestampWithMs();
  };
  Span2.prototype.toTraceparent = function() {
    var sampledString = "";
    if (this.sampled !== void 0) {
      sampledString = this.sampled ? "-1" : "-0";
    }
    return this.traceId + "-" + this.spanId + sampledString;
  };
  Span2.prototype.toContext = function() {
    return dropUndefinedKeys({
      data: this.data,
      description: this.description,
      endTimestamp: this.endTimestamp,
      op: this.op,
      parentSpanId: this.parentSpanId,
      sampled: this.sampled,
      spanId: this.spanId,
      startTimestamp: this.startTimestamp,
      status: this.status,
      tags: this.tags,
      traceId: this.traceId
    });
  };
  Span2.prototype.updateWithContext = function(spanContext) {
    var _a, _b, _c, _d, _e;
    this.data = (_a = spanContext.data, _a !== null && _a !== void 0 ? _a : {});
    this.description = spanContext.description;
    this.endTimestamp = spanContext.endTimestamp;
    this.op = spanContext.op;
    this.parentSpanId = spanContext.parentSpanId;
    this.sampled = spanContext.sampled;
    this.spanId = (_b = spanContext.spanId, _b !== null && _b !== void 0 ? _b : this.spanId);
    this.startTimestamp = (_c = spanContext.startTimestamp, _c !== null && _c !== void 0 ? _c : this.startTimestamp);
    this.status = spanContext.status;
    this.tags = (_d = spanContext.tags, _d !== null && _d !== void 0 ? _d : {});
    this.traceId = (_e = spanContext.traceId, _e !== null && _e !== void 0 ? _e : this.traceId);
    return this;
  };
  Span2.prototype.getTraceContext = function() {
    return dropUndefinedKeys({
      data: Object.keys(this.data).length > 0 ? this.data : void 0,
      description: this.description,
      op: this.op,
      parent_span_id: this.parentSpanId,
      span_id: this.spanId,
      status: this.status,
      tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
      trace_id: this.traceId
    });
  };
  Span2.prototype.toJSON = function() {
    return dropUndefinedKeys({
      data: Object.keys(this.data).length > 0 ? this.data : void 0,
      description: this.description,
      op: this.op,
      parent_span_id: this.parentSpanId,
      span_id: this.spanId,
      start_timestamp: this.startTimestamp,
      status: this.status,
      tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
      timestamp: this.endTimestamp,
      trace_id: this.traceId
    });
  };
  return Span2;
}();
function spanStatusfromHttpCode(httpStatus) {
  if (httpStatus < 400 && httpStatus >= 100) {
    return "ok";
  }
  if (httpStatus >= 400 && httpStatus < 500) {
    switch (httpStatus) {
      case 401:
        return "unauthenticated";
      case 403:
        return "permission_denied";
      case 404:
        return "not_found";
      case 409:
        return "already_exists";
      case 413:
        return "failed_precondition";
      case 429:
        return "resource_exhausted";
      default:
        return "invalid_argument";
    }
  }
  if (httpStatus >= 500 && httpStatus < 600) {
    switch (httpStatus) {
      case 501:
        return "unimplemented";
      case 503:
        return "unavailable";
      case 504:
        return "deadline_exceeded";
      default:
        return "internal_error";
    }
  }
  return "unknown_error";
}

// node_modules/@sentry/tracing/esm/transaction.js
var Transaction = function(_super) {
  __extends(Transaction2, _super);
  function Transaction2(transactionContext, hub) {
    var _this = _super.call(this, transactionContext) || this;
    _this._measurements = {};
    _this._hub = getCurrentHub();
    if (isInstanceOf(hub, Hub)) {
      _this._hub = hub;
    }
    _this.name = transactionContext.name || "";
    _this.metadata = transactionContext.metadata || {};
    _this._trimEnd = transactionContext.trimEnd;
    _this.transaction = _this;
    return _this;
  }
  Transaction2.prototype.setName = function(name) {
    this.name = name;
  };
  Transaction2.prototype.initSpanRecorder = function(maxlen) {
    if (maxlen === void 0) {
      maxlen = 1e3;
    }
    if (!this.spanRecorder) {
      this.spanRecorder = new SpanRecorder(maxlen);
    }
    this.spanRecorder.add(this);
  };
  Transaction2.prototype.setMeasurements = function(measurements) {
    this._measurements = __assign({}, measurements);
  };
  Transaction2.prototype.setMetadata = function(newMetadata) {
    this.metadata = __assign(__assign({}, this.metadata), newMetadata);
  };
  Transaction2.prototype.finish = function(endTimestamp) {
    var _this = this;
    if (this.endTimestamp !== void 0) {
      return void 0;
    }
    if (!this.name) {
      IS_DEBUG_BUILD && logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
      this.name = "<unlabeled transaction>";
    }
    _super.prototype.finish.call(this, endTimestamp);
    if (this.sampled !== true) {
      IS_DEBUG_BUILD && logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
      var client = this._hub.getClient();
      var transport = client && client.getTransport && client.getTransport();
      if (transport && transport.recordLostEvent) {
        transport.recordLostEvent("sample_rate", "transaction");
      }
      return void 0;
    }
    var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function(s) {
      return s !== _this && s.endTimestamp;
    }) : [];
    if (this._trimEnd && finishedSpans.length > 0) {
      this.endTimestamp = finishedSpans.reduce(function(prev, current) {
        if (prev.endTimestamp && current.endTimestamp) {
          return prev.endTimestamp > current.endTimestamp ? prev : current;
        }
        return prev;
      }).endTimestamp;
    }
    var transaction = {
      contexts: {
        trace: this.getTraceContext()
      },
      spans: finishedSpans,
      start_timestamp: this.startTimestamp,
      tags: this.tags,
      timestamp: this.endTimestamp,
      transaction: this.name,
      type: "transaction",
      sdkProcessingMetadata: this.metadata
    };
    var hasMeasurements = Object.keys(this._measurements).length > 0;
    if (hasMeasurements) {
      IS_DEBUG_BUILD && logger.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2));
      transaction.measurements = this._measurements;
    }
    IS_DEBUG_BUILD && logger.log("[Tracing] Finishing " + this.op + " transaction: " + this.name + ".");
    return this._hub.captureEvent(transaction);
  };
  Transaction2.prototype.toContext = function() {
    var spanContext = _super.prototype.toContext.call(this);
    return dropUndefinedKeys(__assign(__assign({}, spanContext), { name: this.name, trimEnd: this._trimEnd }));
  };
  Transaction2.prototype.updateWithContext = function(transactionContext) {
    var _a;
    _super.prototype.updateWithContext.call(this, transactionContext);
    this.name = (_a = transactionContext.name, _a !== null && _a !== void 0 ? _a : "");
    this._trimEnd = transactionContext.trimEnd;
    return this;
  };
  return Transaction2;
}(Span);

// node_modules/@sentry/tracing/esm/idletransaction.js
var DEFAULT_IDLE_TIMEOUT = 1e3;
var HEARTBEAT_INTERVAL = 5e3;
var IdleTransactionSpanRecorder = function(_super) {
  __extends(IdleTransactionSpanRecorder2, _super);
  function IdleTransactionSpanRecorder2(_pushActivity, _popActivity, transactionSpanId, maxlen) {
    if (transactionSpanId === void 0) {
      transactionSpanId = "";
    }
    var _this = _super.call(this, maxlen) || this;
    _this._pushActivity = _pushActivity;
    _this._popActivity = _popActivity;
    _this.transactionSpanId = transactionSpanId;
    return _this;
  }
  IdleTransactionSpanRecorder2.prototype.add = function(span) {
    var _this = this;
    if (span.spanId !== this.transactionSpanId) {
      span.finish = function(endTimestamp) {
        span.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : timestampWithMs();
        _this._popActivity(span.spanId);
      };
      if (span.endTimestamp === void 0) {
        this._pushActivity(span.spanId);
      }
    }
    _super.prototype.add.call(this, span);
  };
  return IdleTransactionSpanRecorder2;
}(SpanRecorder);
var IdleTransaction = function(_super) {
  __extends(IdleTransaction2, _super);
  function IdleTransaction2(transactionContext, _idleHub, _idleTimeout, _onScope) {
    if (_idleTimeout === void 0) {
      _idleTimeout = DEFAULT_IDLE_TIMEOUT;
    }
    if (_onScope === void 0) {
      _onScope = false;
    }
    var _this = _super.call(this, transactionContext, _idleHub) || this;
    _this._idleHub = _idleHub;
    _this._idleTimeout = _idleTimeout;
    _this._onScope = _onScope;
    _this.activities = {};
    _this._heartbeatCounter = 0;
    _this._finished = false;
    _this._beforeFinishCallbacks = [];
    if (_idleHub && _onScope) {
      clearActiveTransaction(_idleHub);
      IS_DEBUG_BUILD && logger.log("Setting idle transaction on scope. Span ID: " + _this.spanId);
      _idleHub.configureScope(function(scope) {
        return scope.setSpan(_this);
      });
    }
    _this._initTimeout = setTimeout(function() {
      if (!_this._finished) {
        _this.finish();
      }
    }, _this._idleTimeout);
    return _this;
  }
  IdleTransaction2.prototype.finish = function(endTimestamp) {
    var e_1, _a;
    var _this = this;
    if (endTimestamp === void 0) {
      endTimestamp = timestampWithMs();
    }
    this._finished = true;
    this.activities = {};
    if (this.spanRecorder) {
      IS_DEBUG_BUILD && logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestamp * 1e3).toISOString(), this.op);
      try {
        for (var _b = __values(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
          var callback = _c.value;
          callback(this, endTimestamp);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      this.spanRecorder.spans = this.spanRecorder.spans.filter(function(span) {
        if (span.spanId === _this.spanId) {
          return true;
        }
        if (!span.endTimestamp) {
          span.endTimestamp = endTimestamp;
          span.setStatus("cancelled");
          IS_DEBUG_BUILD && logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span, void 0, 2));
        }
        var keepSpan = span.startTimestamp < endTimestamp;
        if (!keepSpan) {
          IS_DEBUG_BUILD && logger.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(span, void 0, 2));
        }
        return keepSpan;
      });
      IS_DEBUG_BUILD && logger.log("[Tracing] flushing IdleTransaction");
    } else {
      IS_DEBUG_BUILD && logger.log("[Tracing] No active IdleTransaction");
    }
    if (this._onScope) {
      clearActiveTransaction(this._idleHub);
    }
    return _super.prototype.finish.call(this, endTimestamp);
  };
  IdleTransaction2.prototype.registerBeforeFinishCallback = function(callback) {
    this._beforeFinishCallbacks.push(callback);
  };
  IdleTransaction2.prototype.initSpanRecorder = function(maxlen) {
    var _this = this;
    if (!this.spanRecorder) {
      var pushActivity = function(id) {
        if (_this._finished) {
          return;
        }
        _this._pushActivity(id);
      };
      var popActivity = function(id) {
        if (_this._finished) {
          return;
        }
        _this._popActivity(id);
      };
      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
      IS_DEBUG_BUILD && logger.log("Starting heartbeat");
      this._pingHeartbeat();
    }
    this.spanRecorder.add(this);
  };
  IdleTransaction2.prototype._pushActivity = function(spanId) {
    if (this._initTimeout) {
      clearTimeout(this._initTimeout);
      this._initTimeout = void 0;
    }
    IS_DEBUG_BUILD && logger.log("[Tracing] pushActivity: " + spanId);
    this.activities[spanId] = true;
    IS_DEBUG_BUILD && logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
  };
  IdleTransaction2.prototype._popActivity = function(spanId) {
    var _this = this;
    if (this.activities[spanId]) {
      IS_DEBUG_BUILD && logger.log("[Tracing] popActivity " + spanId);
      delete this.activities[spanId];
      IS_DEBUG_BUILD && logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
    }
    if (Object.keys(this.activities).length === 0) {
      var timeout = this._idleTimeout;
      var end_1 = timestampWithMs() + timeout / 1e3;
      setTimeout(function() {
        if (!_this._finished) {
          _this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[1]);
          _this.finish(end_1);
        }
      }, timeout);
    }
  };
  IdleTransaction2.prototype._beat = function() {
    if (this._finished) {
      return;
    }
    var heartbeatString = Object.keys(this.activities).join("");
    if (heartbeatString === this._prevHeartbeatString) {
      this._heartbeatCounter += 1;
    } else {
      this._heartbeatCounter = 1;
    }
    this._prevHeartbeatString = heartbeatString;
    if (this._heartbeatCounter >= 3) {
      IS_DEBUG_BUILD && logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
      this.setStatus("deadline_exceeded");
      this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[0]);
      this.finish();
    } else {
      this._pingHeartbeat();
    }
  };
  IdleTransaction2.prototype._pingHeartbeat = function() {
    var _this = this;
    IS_DEBUG_BUILD && logger.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter);
    setTimeout(function() {
      _this._beat();
    }, HEARTBEAT_INTERVAL);
  };
  return IdleTransaction2;
}(Transaction);
function clearActiveTransaction(hub) {
  if (hub) {
    var scope = hub.getScope();
    if (scope) {
      var transaction = scope.getTransaction();
      if (transaction) {
        scope.setSpan(void 0);
      }
    }
  }
}

// node_modules/@sentry/tracing/esm/hubextensions.js
function traceHeaders() {
  var scope = this.getScope();
  if (scope) {
    var span = scope.getSpan();
    if (span) {
      return {
        "sentry-trace": span.toTraceparent()
      };
    }
  }
  return {};
}
function sample(transaction, options, samplingContext) {
  if (!hasTracingEnabled(options)) {
    transaction.sampled = false;
    return transaction;
  }
  if (transaction.sampled !== void 0) {
    transaction.setMetadata({
      transactionSampling: { method: "explicitly_set" }
    });
    return transaction;
  }
  var sampleRate;
  if (typeof options.tracesSampler === "function") {
    sampleRate = options.tracesSampler(samplingContext);
    transaction.setMetadata({
      transactionSampling: {
        method: "client_sampler",
        rate: Number(sampleRate)
      }
    });
  } else if (samplingContext.parentSampled !== void 0) {
    sampleRate = samplingContext.parentSampled;
    transaction.setMetadata({
      transactionSampling: { method: "inheritance" }
    });
  } else {
    sampleRate = options.tracesSampleRate;
    transaction.setMetadata({
      transactionSampling: {
        method: "client_rate",
        rate: Number(sampleRate)
      }
    });
  }
  if (!isValidSampleRate(sampleRate)) {
    IS_DEBUG_BUILD && logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
    transaction.sampled = false;
    return transaction;
  }
  if (!sampleRate) {
    IS_DEBUG_BUILD && logger.log("[Tracing] Discarding transaction because " + (typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"));
    transaction.sampled = false;
    return transaction;
  }
  transaction.sampled = Math.random() < sampleRate;
  if (!transaction.sampled) {
    IS_DEBUG_BUILD && logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
    return transaction;
  }
  IS_DEBUG_BUILD && logger.log("[Tracing] starting " + transaction.op + " transaction - " + transaction.name);
  return transaction;
}
function isValidSampleRate(rate) {
  if (isNaN(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
    IS_DEBUG_BUILD && logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(rate) + " of type " + JSON.stringify(typeof rate) + ".");
    return false;
  }
  if (rate < 0 || rate > 1) {
    IS_DEBUG_BUILD && logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + rate + ".");
    return false;
  }
  return true;
}
function _startTransaction(transactionContext, customSamplingContext) {
  var client = this.getClient();
  var options = client && client.getOptions() || {};
  var transaction = new Transaction(transactionContext, this);
  transaction = sample(transaction, options, __assign({ parentSampled: transactionContext.parentSampled, transactionContext }, customSamplingContext));
  if (transaction.sampled) {
    transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
  }
  return transaction;
}
function startIdleTransaction(hub, transactionContext, idleTimeout, onScope, customSamplingContext) {
  var client = hub.getClient();
  var options = client && client.getOptions() || {};
  var transaction = new IdleTransaction(transactionContext, hub, idleTimeout, onScope);
  transaction = sample(transaction, options, __assign({ parentSampled: transactionContext.parentSampled, transactionContext }, customSamplingContext));
  if (transaction.sampled) {
    transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
  }
  return transaction;
}
function _addTracingExtensions() {
  var carrier = getMainCarrier();
  if (!carrier.__SENTRY__) {
    return;
  }
  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
  if (!carrier.__SENTRY__.extensions.startTransaction) {
    carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
  }
  if (!carrier.__SENTRY__.extensions.traceHeaders) {
    carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
  }
}
function _autoloadDatabaseIntegrations() {
  var carrier = getMainCarrier();
  if (!carrier.__SENTRY__) {
    return;
  }
  var packageToIntegrationMapping = {
    mongodb: function() {
      var integration = dynamicRequire(module, "./integrations/node/mongo");
      return new integration.Mongo();
    },
    mongoose: function() {
      var integration = dynamicRequire(module, "./integrations/node/mongo");
      return new integration.Mongo({ mongoose: true });
    },
    mysql: function() {
      var integration = dynamicRequire(module, "./integrations/node/mysql");
      return new integration.Mysql();
    },
    pg: function() {
      var integration = dynamicRequire(module, "./integrations/node/postgres");
      return new integration.Postgres();
    }
  };
  var mappedPackages = Object.keys(packageToIntegrationMapping).filter(function(moduleName) {
    return !!loadModule(moduleName);
  }).map(function(pkg) {
    try {
      return packageToIntegrationMapping[pkg]();
    } catch (e) {
      return void 0;
    }
  }).filter(function(p) {
    return p;
  });
  if (mappedPackages.length > 0) {
    carrier.__SENTRY__.integrations = __spread(carrier.__SENTRY__.integrations || [], mappedPackages);
  }
}
function addExtensionMethods() {
  _addTracingExtensions();
  if (isNodeEnv()) {
    _autoloadDatabaseIntegrations();
  }
  registerErrorInstrumentation();
}

// node_modules/@sentry/tracing/esm/integrations/index.js
var integrations_exports = {};
__export(integrations_exports, {
  BrowserTracing: () => BrowserTracing,
  Express: () => Express,
  Mongo: () => Mongo,
  Mysql: () => Mysql,
  Postgres: () => Postgres
});

// node_modules/@sentry/tracing/esm/integrations/node/express.js
var Express = function() {
  function Express2(options) {
    if (options === void 0) {
      options = {};
    }
    this.name = Express2.id;
    this._router = options.router || options.app;
    this._methods = (Array.isArray(options.methods) ? options.methods : []).concat("use");
  }
  Express2.prototype.setupOnce = function() {
    if (!this._router) {
      IS_DEBUG_BUILD && logger.error("ExpressIntegration is missing an Express instance");
      return;
    }
    instrumentMiddlewares(this._router, this._methods);
  };
  Express2.id = "Express";
  return Express2;
}();
function wrap(fn, method) {
  var arity = fn.length;
  switch (arity) {
    case 2: {
      return function(req, res) {
        var transaction = res.__sentry_transaction;
        if (transaction) {
          var span_1 = transaction.startChild({
            description: fn.name,
            op: "express.middleware." + method
          });
          res.once("finish", function() {
            span_1.finish();
          });
        }
        return fn.call(this, req, res);
      };
    }
    case 3: {
      return function(req, res, next) {
        var _a;
        var transaction = res.__sentry_transaction;
        var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({
          description: fn.name,
          op: "express.middleware." + method
        });
        fn.call(this, req, res, function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _a2;
          (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
          next.call.apply(next, __spread([this], args));
        });
      };
    }
    case 4: {
      return function(err, req, res, next) {
        var _a;
        var transaction = res.__sentry_transaction;
        var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({
          description: fn.name,
          op: "express.middleware." + method
        });
        fn.call(this, err, req, res, function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _a2;
          (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
          next.call.apply(next, __spread([this], args));
        });
      };
    }
    default: {
      throw new Error("Express middleware takes 2-4 arguments. Got: " + arity);
    }
  }
}
function wrapMiddlewareArgs(args, method) {
  return args.map(function(arg) {
    if (typeof arg === "function") {
      return wrap(arg, method);
    }
    if (Array.isArray(arg)) {
      return arg.map(function(a) {
        if (typeof a === "function") {
          return wrap(a, method);
        }
        return a;
      });
    }
    return arg;
  });
}
function patchMiddleware(router, method) {
  var originalCallback = router[method];
  router[method] = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return originalCallback.call.apply(originalCallback, __spread([this], wrapMiddlewareArgs(args, method)));
  };
  return router;
}
function instrumentMiddlewares(router, methods) {
  if (methods === void 0) {
    methods = [];
  }
  methods.forEach(function(method) {
    return patchMiddleware(router, method);
  });
}

// node_modules/@sentry/tracing/esm/integrations/node/postgres.js
var Postgres = function() {
  function Postgres2(options) {
    if (options === void 0) {
      options = {};
    }
    this.name = Postgres2.id;
    this._usePgNative = !!options.usePgNative;
  }
  Postgres2.prototype.setupOnce = function(_, getCurrentHub2) {
    var _a;
    var pkg = loadModule("pg");
    if (!pkg) {
      IS_DEBUG_BUILD && logger.error("Postgres Integration was unable to require `pg` package.");
      return;
    }
    if (this._usePgNative && !((_a = pkg.native) === null || _a === void 0 ? void 0 : _a.Client)) {
      IS_DEBUG_BUILD && logger.error("Postgres Integration was unable to access 'pg-native' bindings.");
      return;
    }
    var Client = (this._usePgNative ? pkg.native : pkg).Client;
    fill(Client.prototype, "query", function(orig) {
      return function(config, values, callback) {
        var _a2, _b, _c;
        var scope = getCurrentHub2().getScope();
        var parentSpan = (_a2 = scope) === null || _a2 === void 0 ? void 0 : _a2.getSpan();
        var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
          description: typeof config === "string" ? config : config.text,
          op: "db"
        });
        if (typeof callback === "function") {
          return orig.call(this, config, values, function(err, result) {
            var _a3;
            (_a3 = span) === null || _a3 === void 0 ? void 0 : _a3.finish();
            callback(err, result);
          });
        }
        if (typeof values === "function") {
          return orig.call(this, config, function(err, result) {
            var _a3;
            (_a3 = span) === null || _a3 === void 0 ? void 0 : _a3.finish();
            values(err, result);
          });
        }
        var rv = typeof values !== "undefined" ? orig.call(this, config, values) : orig.call(this, config);
        if (isThenable(rv)) {
          return rv.then(function(res) {
            var _a3;
            (_a3 = span) === null || _a3 === void 0 ? void 0 : _a3.finish();
            return res;
          });
        }
        (_c = span) === null || _c === void 0 ? void 0 : _c.finish();
        return rv;
      };
    });
  };
  Postgres2.id = "Postgres";
  return Postgres2;
}();

// node_modules/@sentry/tracing/esm/integrations/node/mysql.js
var Mysql = function() {
  function Mysql2() {
    this.name = Mysql2.id;
  }
  Mysql2.prototype.setupOnce = function(_, getCurrentHub2) {
    var pkg = loadModule("mysql/lib/Connection.js");
    if (!pkg) {
      IS_DEBUG_BUILD && logger.error("Mysql Integration was unable to require `mysql` package.");
      return;
    }
    fill(pkg, "createQuery", function(orig) {
      return function(options, values, callback) {
        var _a, _b;
        var scope = getCurrentHub2().getScope();
        var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
        var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
          description: typeof options === "string" ? options : options.sql,
          op: "db"
        });
        if (typeof callback === "function") {
          return orig.call(this, options, values, function(err, result, fields) {
            var _a2;
            (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
            callback(err, result, fields);
          });
        }
        if (typeof values === "function") {
          return orig.call(this, options, function(err, result, fields) {
            var _a2;
            (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
            values(err, result, fields);
          });
        }
        return orig.call(this, options, values, callback);
      };
    });
  };
  Mysql2.id = "Mysql";
  return Mysql2;
}();

// node_modules/@sentry/tracing/esm/integrations/node/mongo.js
var OPERATIONS = [
  "aggregate",
  "bulkWrite",
  "countDocuments",
  "createIndex",
  "createIndexes",
  "deleteMany",
  "deleteOne",
  "distinct",
  "drop",
  "dropIndex",
  "dropIndexes",
  "estimatedDocumentCount",
  "find",
  "findOne",
  "findOneAndDelete",
  "findOneAndReplace",
  "findOneAndUpdate",
  "indexes",
  "indexExists",
  "indexInformation",
  "initializeOrderedBulkOp",
  "insertMany",
  "insertOne",
  "isCapped",
  "mapReduce",
  "options",
  "parallelCollectionScan",
  "rename",
  "replaceOne",
  "stats",
  "updateMany",
  "updateOne"
];
var OPERATION_SIGNATURES = {
  bulkWrite: ["operations"],
  countDocuments: ["query"],
  createIndex: ["fieldOrSpec"],
  createIndexes: ["indexSpecs"],
  deleteMany: ["filter"],
  deleteOne: ["filter"],
  distinct: ["key", "query"],
  dropIndex: ["indexName"],
  find: ["query"],
  findOne: ["query"],
  findOneAndDelete: ["filter"],
  findOneAndReplace: ["filter", "replacement"],
  findOneAndUpdate: ["filter", "update"],
  indexExists: ["indexes"],
  insertMany: ["docs"],
  insertOne: ["doc"],
  mapReduce: ["map", "reduce"],
  rename: ["newName"],
  replaceOne: ["filter", "doc"],
  updateMany: ["filter", "update"],
  updateOne: ["filter", "update"]
};
var Mongo = function() {
  function Mongo2(options) {
    if (options === void 0) {
      options = {};
    }
    this.name = Mongo2.id;
    this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;
    this._describeOperations = "describeOperations" in options ? options.describeOperations : true;
    this._useMongoose = !!options.useMongoose;
  }
  Mongo2.prototype.setupOnce = function(_, getCurrentHub2) {
    var moduleName = this._useMongoose ? "mongoose" : "mongodb";
    var pkg = loadModule(moduleName);
    if (!pkg) {
      IS_DEBUG_BUILD && logger.error("Mongo Integration was unable to require `" + moduleName + "` package.");
      return;
    }
    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub2);
  };
  Mongo2.prototype._instrumentOperations = function(collection, operations, getCurrentHub2) {
    var _this = this;
    operations.forEach(function(operation) {
      return _this._patchOperation(collection, operation, getCurrentHub2);
    });
  };
  Mongo2.prototype._patchOperation = function(collection, operation, getCurrentHub2) {
    if (!(operation in collection.prototype))
      return;
    var getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
    fill(collection.prototype, operation, function(orig) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var _a, _b, _c, _d;
        var lastArg = args[args.length - 1];
        var scope = getCurrentHub2().getScope();
        var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
        if (typeof lastArg !== "function" || operation === "mapReduce" && args.length === 2) {
          var span_1 = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild(getSpanContext(this, operation, args));
          var maybePromise = orig.call.apply(orig, __spread([this], args));
          if (isThenable(maybePromise)) {
            return maybePromise.then(function(res) {
              var _a2;
              (_a2 = span_1) === null || _a2 === void 0 ? void 0 : _a2.finish();
              return res;
            });
          } else {
            (_c = span_1) === null || _c === void 0 ? void 0 : _c.finish();
            return maybePromise;
          }
        }
        var span = (_d = parentSpan) === null || _d === void 0 ? void 0 : _d.startChild(getSpanContext(this, operation, args.slice(0, -1)));
        return orig.call.apply(orig, __spread([this], args.slice(0, -1), [function(err, result) {
          var _a2;
          (_a2 = span) === null || _a2 === void 0 ? void 0 : _a2.finish();
          lastArg(err, result);
        }]));
      };
    });
  };
  Mongo2.prototype._getSpanContextFromOperationArguments = function(collection, operation, args) {
    var data = {
      collectionName: collection.collectionName,
      dbName: collection.dbName,
      namespace: collection.namespace
    };
    var spanContext = {
      op: "db",
      description: operation,
      data
    };
    var signature = OPERATION_SIGNATURES[operation];
    var shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;
    if (!signature || !shouldDescribe) {
      return spanContext;
    }
    try {
      if (operation === "mapReduce") {
        var _a = __read(args, 2), map = _a[0], reduce = _a[1];
        data[signature[0]] = typeof map === "string" ? map : map.name || "<anonymous>";
        data[signature[1]] = typeof reduce === "string" ? reduce : reduce.name || "<anonymous>";
      } else {
        for (var i = 0; i < signature.length; i++) {
          data[signature[i]] = JSON.stringify(args[i]);
        }
      }
    } catch (_oO) {
    }
    return spanContext;
  };
  Mongo2.id = "Mongo";
  return Mongo2;
}();

// node_modules/@sentry/tracing/esm/browser/backgroundtab.js
var global = getGlobalObject();
function registerBackgroundTabDetection() {
  if (global && global.document) {
    global.document.addEventListener("visibilitychange", function() {
      var activeTransaction = getActiveTransaction();
      if (global.document.hidden && activeTransaction) {
        var statusType = "cancelled";
        IS_DEBUG_BUILD && logger.log("[Tracing] Transaction: " + statusType + " -> since tab moved to the background, op: " + activeTransaction.op);
        if (!activeTransaction.status) {
          activeTransaction.setStatus(statusType);
        }
        activeTransaction.setTag("visibilitychange", "document.hidden");
        activeTransaction.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[2]);
        activeTransaction.finish();
      }
    });
  } else {
    IS_DEBUG_BUILD && logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
  }
}

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/bindReporter.js
var bindReporter = function(callback, metric, reportAllChanges) {
  var prevValue;
  return function(forceReport) {
    if (metric.value >= 0) {
      if (forceReport || reportAllChanges) {
        metric.delta = metric.value - (prevValue || 0);
        if (metric.delta || prevValue === void 0) {
          prevValue = metric.value;
          callback(metric);
        }
      }
    }
  };
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/generateUniqueID.js
var generateUniqueID = function() {
  return "v2-" + Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/initMetric.js
var initMetric = function(name, value) {
  return {
    name,
    value: value !== null && value !== void 0 ? value : -1,
    delta: 0,
    entries: [],
    id: generateUniqueID()
  };
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/observe.js
var observe = function(type, callback) {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(type)) {
      if (type === "first-input" && !("PerformanceEventTiming" in self)) {
        return;
      }
      var po = new PerformanceObserver(function(l) {
        return l.getEntries().map(callback);
      });
      po.observe({ type, buffered: true });
      return po;
    }
  } catch (e) {
  }
  return;
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/onHidden.js
var onHidden = function(cb, once) {
  var onHiddenOrPageHide = function(event) {
    if (event.type === "pagehide" || getGlobalObject().document.visibilityState === "hidden") {
      cb(event);
      if (once) {
        removeEventListener("visibilitychange", onHiddenOrPageHide, true);
        removeEventListener("pagehide", onHiddenOrPageHide, true);
      }
    }
  };
  addEventListener("visibilitychange", onHiddenOrPageHide, true);
  addEventListener("pagehide", onHiddenOrPageHide, true);
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/getCLS.js
var getCLS = function(onReport, reportAllChanges) {
  var metric = initMetric("CLS", 0);
  var report;
  var sessionValue = 0;
  var sessionEntries = [];
  var entryHandler = function(entry) {
    if (entry && !entry.hadRecentInput) {
      var firstSessionEntry = sessionEntries[0];
      var lastSessionEntry = sessionEntries[sessionEntries.length - 1];
      if (sessionValue && sessionEntries.length !== 0 && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {
        sessionValue += entry.value;
        sessionEntries.push(entry);
      } else {
        sessionValue = entry.value;
        sessionEntries = [entry];
      }
      if (sessionValue > metric.value) {
        metric.value = sessionValue;
        metric.entries = sessionEntries;
        if (report) {
          report();
        }
      }
    }
  };
  var po = observe("layout-shift", entryHandler);
  if (po) {
    report = bindReporter(onReport, metric, reportAllChanges);
    onHidden(function() {
      po.takeRecords().map(entryHandler);
      report(true);
    });
  }
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getVisibilityWatcher.js
var firstHiddenTime = -1;
var initHiddenTime = function() {
  return getGlobalObject().document.visibilityState === "hidden" ? 0 : Infinity;
};
var trackChanges = function() {
  onHidden(function(_a) {
    var timeStamp = _a.timeStamp;
    firstHiddenTime = timeStamp;
  }, true);
};
var getVisibilityWatcher = function() {
  if (firstHiddenTime < 0) {
    firstHiddenTime = initHiddenTime();
    trackChanges();
  }
  return {
    get firstHiddenTime() {
      return firstHiddenTime;
    }
  };
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/getFID.js
var getFID = function(onReport, reportAllChanges) {
  var visibilityWatcher = getVisibilityWatcher();
  var metric = initMetric("FID");
  var report;
  var entryHandler = function(entry) {
    if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {
      metric.value = entry.processingStart - entry.startTime;
      metric.entries.push(entry);
      report(true);
    }
  };
  var po = observe("first-input", entryHandler);
  if (po) {
    report = bindReporter(onReport, metric, reportAllChanges);
    onHidden(function() {
      po.takeRecords().map(entryHandler);
      po.disconnect();
    }, true);
  }
};

// node_modules/@sentry/tracing/esm/browser/web-vitals/getLCP.js
var reportedMetricIDs = {};
var getLCP = function(onReport, reportAllChanges) {
  var visibilityWatcher = getVisibilityWatcher();
  var metric = initMetric("LCP");
  var report;
  var entryHandler = function(entry) {
    var value = entry.startTime;
    if (value < visibilityWatcher.firstHiddenTime) {
      metric.value = value;
      metric.entries.push(entry);
    }
    if (report) {
      report();
    }
  };
  var po = observe("largest-contentful-paint", entryHandler);
  if (po) {
    report = bindReporter(onReport, metric, reportAllChanges);
    var stopListening_1 = function() {
      if (!reportedMetricIDs[metric.id]) {
        po.takeRecords().map(entryHandler);
        po.disconnect();
        reportedMetricIDs[metric.id] = true;
        report(true);
      }
    };
    ["keydown", "click"].forEach(function(type) {
      addEventListener(type, stopListening_1, { once: true, capture: true });
    });
    onHidden(stopListening_1, true);
  }
};

// node_modules/@sentry/tracing/esm/browser/metrics.js
var global2 = getGlobalObject();
var MetricsInstrumentation = function() {
  function MetricsInstrumentation2(_reportAllChanges) {
    if (_reportAllChanges === void 0) {
      _reportAllChanges = false;
    }
    this._reportAllChanges = _reportAllChanges;
    this._measurements = {};
    this._performanceCursor = 0;
    if (!isNodeEnv() && global2 && global2.performance && global2.document) {
      if (global2.performance.mark) {
        global2.performance.mark("sentry-tracing-init");
      }
      this._trackCLS();
      this._trackLCP();
      this._trackFID();
    }
  }
  MetricsInstrumentation2.prototype.addPerformanceEntries = function(transaction) {
    var _this = this;
    if (!global2 || !global2.performance || !global2.performance.getEntries || !browserPerformanceTimeOrigin) {
      return;
    }
    IS_DEBUG_BUILD && logger.log("[Tracing] Adding & adjusting spans using Performance API");
    var timeOrigin = msToSec(browserPerformanceTimeOrigin);
    var responseStartTimestamp;
    var requestStartTimestamp;
    global2.performance.getEntries().slice(this._performanceCursor).forEach(function(entry) {
      var startTime = msToSec(entry.startTime);
      var duration = msToSec(entry.duration);
      if (transaction.op === "navigation" && timeOrigin + startTime < transaction.startTimestamp) {
        return;
      }
      switch (entry.entryType) {
        case "navigation": {
          addNavigationSpans(transaction, entry, timeOrigin);
          responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);
          requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);
          break;
        }
        case "mark":
        case "paint":
        case "measure": {
          var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
          var firstHidden = getVisibilityWatcher();
          var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
          if (entry.name === "first-paint" && shouldRecord) {
            IS_DEBUG_BUILD && logger.log("[Measurements] Adding FP");
            _this._measurements["fp"] = { value: entry.startTime };
            _this._measurements["mark.fp"] = { value: startTimestamp };
          }
          if (entry.name === "first-contentful-paint" && shouldRecord) {
            IS_DEBUG_BUILD && logger.log("[Measurements] Adding FCP");
            _this._measurements["fcp"] = { value: entry.startTime };
            _this._measurements["mark.fcp"] = { value: startTimestamp };
          }
          break;
        }
        case "resource": {
          var resourceName = entry.name.replace(global2.location.origin, "");
          addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
          break;
        }
        default:
      }
    });
    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
    this._trackNavigator(transaction);
    if (transaction.op === "pageload") {
      var timeOrigin_1 = msToSec(browserPerformanceTimeOrigin);
      if (typeof responseStartTimestamp === "number") {
        IS_DEBUG_BUILD && logger.log("[Measurements] Adding TTFB");
        this._measurements["ttfb"] = { value: (responseStartTimestamp - transaction.startTimestamp) * 1e3 };
        if (typeof requestStartTimestamp === "number" && requestStartTimestamp <= responseStartTimestamp) {
          this._measurements["ttfb.requestTime"] = { value: (responseStartTimestamp - requestStartTimestamp) * 1e3 };
        }
      }
      ["fcp", "fp", "lcp"].forEach(function(name) {
        if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {
          return;
        }
        var oldValue = _this._measurements[name].value;
        var measurementTimestamp = timeOrigin_1 + msToSec(oldValue);
        var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1e3);
        var delta = normalizedValue - oldValue;
        IS_DEBUG_BUILD && logger.log("[Measurements] Normalized " + name + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
        _this._measurements[name].value = normalizedValue;
      });
      if (this._measurements["mark.fid"] && this._measurements["fid"]) {
        _startChild(transaction, {
          description: "first input delay",
          endTimestamp: this._measurements["mark.fid"].value + msToSec(this._measurements["fid"].value),
          op: "web.vitals",
          startTimestamp: this._measurements["mark.fid"].value
        });
      }
      if (!("fcp" in this._measurements)) {
        delete this._measurements.cls;
      }
      transaction.setMeasurements(this._measurements);
      tagMetricInfo(transaction, this._lcpEntry, this._clsEntry);
      transaction.setTag("sentry_reportAllChanges", this._reportAllChanges);
    }
  };
  MetricsInstrumentation2.prototype._trackNavigator = function(transaction) {
    var navigator = global2.navigator;
    if (!navigator) {
      return;
    }
    var connection = navigator.connection;
    if (connection) {
      if (connection.effectiveType) {
        transaction.setTag("effectiveConnectionType", connection.effectiveType);
      }
      if (connection.type) {
        transaction.setTag("connectionType", connection.type);
      }
      if (isMeasurementValue(connection.rtt)) {
        this._measurements["connection.rtt"] = { value: connection.rtt };
      }
      if (isMeasurementValue(connection.downlink)) {
        this._measurements["connection.downlink"] = { value: connection.downlink };
      }
    }
    if (isMeasurementValue(navigator.deviceMemory)) {
      transaction.setTag("deviceMemory", String(navigator.deviceMemory));
    }
    if (isMeasurementValue(navigator.hardwareConcurrency)) {
      transaction.setTag("hardwareConcurrency", String(navigator.hardwareConcurrency));
    }
  };
  MetricsInstrumentation2.prototype._trackCLS = function() {
    var _this = this;
    getCLS(function(metric) {
      var entry = metric.entries.pop();
      if (!entry) {
        return;
      }
      IS_DEBUG_BUILD && logger.log("[Measurements] Adding CLS");
      _this._measurements["cls"] = { value: metric.value };
      _this._clsEntry = entry;
    });
  };
  MetricsInstrumentation2.prototype._trackLCP = function() {
    var _this = this;
    getLCP(function(metric) {
      var entry = metric.entries.pop();
      if (!entry) {
        return;
      }
      var timeOrigin = msToSec(browserPerformanceTimeOrigin);
      var startTime = msToSec(entry.startTime);
      IS_DEBUG_BUILD && logger.log("[Measurements] Adding LCP");
      _this._measurements["lcp"] = { value: metric.value };
      _this._measurements["mark.lcp"] = { value: timeOrigin + startTime };
      _this._lcpEntry = entry;
    }, this._reportAllChanges);
  };
  MetricsInstrumentation2.prototype._trackFID = function() {
    var _this = this;
    getFID(function(metric) {
      var entry = metric.entries.pop();
      if (!entry) {
        return;
      }
      var timeOrigin = msToSec(browserPerformanceTimeOrigin);
      var startTime = msToSec(entry.startTime);
      IS_DEBUG_BUILD && logger.log("[Measurements] Adding FID");
      _this._measurements["fid"] = { value: metric.value };
      _this._measurements["mark.fid"] = { value: timeOrigin + startTime };
    });
  };
  return MetricsInstrumentation2;
}();
function addNavigationSpans(transaction, entry, timeOrigin) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(function(event) {
    addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
  });
  addPerformanceNavigationTiming(transaction, entry, "secureConnection", timeOrigin, "TLS/SSL", "connectEnd");
  addPerformanceNavigationTiming(transaction, entry, "fetch", timeOrigin, "cache", "domainLookupStart");
  addPerformanceNavigationTiming(transaction, entry, "domainLookup", timeOrigin, "DNS");
  addRequest(transaction, entry, timeOrigin);
}
function addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
  var measureStartTimestamp = timeOrigin + startTime;
  var measureEndTimestamp = measureStartTimestamp + duration;
  _startChild(transaction, {
    description: entry.name,
    endTimestamp: measureEndTimestamp,
    op: entry.entryType,
    startTimestamp: measureStartTimestamp
  });
  return measureStartTimestamp;
}
function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
  if (entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch") {
    return;
  }
  var data = {};
  if ("transferSize" in entry) {
    data["Transfer Size"] = entry.transferSize;
  }
  if ("encodedBodySize" in entry) {
    data["Encoded Body Size"] = entry.encodedBodySize;
  }
  if ("decodedBodySize" in entry) {
    data["Decoded Body Size"] = entry.decodedBodySize;
  }
  var startTimestamp = timeOrigin + startTime;
  var endTimestamp = startTimestamp + duration;
  _startChild(transaction, {
    description: resourceName,
    endTimestamp,
    op: entry.initiatorType ? "resource." + entry.initiatorType : "resource",
    startTimestamp,
    data
  });
}
function addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {
  var end = eventEnd ? entry[eventEnd] : entry[event + "End"];
  var start = entry[event + "Start"];
  if (!start || !end) {
    return;
  }
  _startChild(transaction, {
    op: "browser",
    description: description !== null && description !== void 0 ? description : event,
    startTimestamp: timeOrigin + msToSec(start),
    endTimestamp: timeOrigin + msToSec(end)
  });
}
function addRequest(transaction, entry, timeOrigin) {
  _startChild(transaction, {
    op: "browser",
    description: "request",
    startTimestamp: timeOrigin + msToSec(entry.requestStart),
    endTimestamp: timeOrigin + msToSec(entry.responseEnd)
  });
  _startChild(transaction, {
    op: "browser",
    description: "response",
    startTimestamp: timeOrigin + msToSec(entry.responseStart),
    endTimestamp: timeOrigin + msToSec(entry.responseEnd)
  });
}
function _startChild(transaction, _a) {
  var startTimestamp = _a.startTimestamp, ctx = __rest(_a, ["startTimestamp"]);
  if (startTimestamp && transaction.startTimestamp > startTimestamp) {
    transaction.startTimestamp = startTimestamp;
  }
  return transaction.startChild(__assign({ startTimestamp }, ctx));
}
function isMeasurementValue(value) {
  return typeof value === "number" && isFinite(value);
}
function tagMetricInfo(transaction, lcpEntry, clsEntry) {
  if (lcpEntry) {
    IS_DEBUG_BUILD && logger.log("[Measurements] Adding LCP Data");
    if (lcpEntry.element) {
      transaction.setTag("lcp.element", htmlTreeAsString(lcpEntry.element));
    }
    if (lcpEntry.id) {
      transaction.setTag("lcp.id", lcpEntry.id);
    }
    if (lcpEntry.url) {
      transaction.setTag("lcp.url", lcpEntry.url.trim().slice(0, 200));
    }
    transaction.setTag("lcp.size", lcpEntry.size);
  }
  if (clsEntry && clsEntry.sources) {
    IS_DEBUG_BUILD && logger.log("[Measurements] Adding CLS Data");
    clsEntry.sources.forEach(function(source, index) {
      return transaction.setTag("cls.source." + (index + 1), htmlTreeAsString(source.node));
    });
  }
}

// node_modules/@sentry/tracing/esm/browser/request.js
var DEFAULT_TRACING_ORIGINS = ["localhost", /^\//];
var defaultRequestInstrumentationOptions = {
  traceFetch: true,
  traceXHR: true,
  tracingOrigins: DEFAULT_TRACING_ORIGINS
};
function instrumentOutgoingRequests(_options) {
  var _a = __assign(__assign({}, defaultRequestInstrumentationOptions), _options), traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
  var urlMap = {};
  var defaultShouldCreateSpan = function(url) {
    if (urlMap[url]) {
      return urlMap[url];
    }
    var origins = tracingOrigins;
    urlMap[url] = origins.some(function(origin) {
      return isMatchingPattern(url, origin);
    }) && !isMatchingPattern(url, "sentry_key");
    return urlMap[url];
  };
  var shouldCreateSpan = defaultShouldCreateSpan;
  if (typeof shouldCreateSpanForRequest === "function") {
    shouldCreateSpan = function(url) {
      return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
    };
  }
  var spans = {};
  if (traceFetch) {
    addInstrumentationHandler("fetch", function(handlerData) {
      fetchCallback(handlerData, shouldCreateSpan, spans);
    });
  }
  if (traceXHR) {
    addInstrumentationHandler("xhr", function(handlerData) {
      xhrCallback(handlerData, shouldCreateSpan, spans);
    });
  }
}
function fetchCallback(handlerData, shouldCreateSpan, spans) {
  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
    return;
  }
  if (handlerData.endTimestamp) {
    var spanId = handlerData.fetchData.__span;
    if (!spanId)
      return;
    var span = spans[spanId];
    if (span) {
      if (handlerData.response) {
        span.setHttpStatus(handlerData.response.status);
      } else if (handlerData.error) {
        span.setStatus("internal_error");
      }
      span.finish();
      delete spans[spanId];
    }
    return;
  }
  var activeTransaction = getActiveTransaction();
  if (activeTransaction) {
    var span = activeTransaction.startChild({
      data: __assign(__assign({}, handlerData.fetchData), { type: "fetch" }),
      description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
      op: "http.client"
    });
    handlerData.fetchData.__span = span.spanId;
    spans[span.spanId] = span;
    var request = handlerData.args[0] = handlerData.args[0];
    var options = handlerData.args[1] = handlerData.args[1] || {};
    var headers = options.headers;
    if (isInstanceOf(request, Request)) {
      headers = request.headers;
    }
    if (headers) {
      if (typeof headers.append === "function") {
        headers.append("sentry-trace", span.toTraceparent());
      } else if (Array.isArray(headers)) {
        headers = __spread(headers, [["sentry-trace", span.toTraceparent()]]);
      } else {
        headers = __assign(__assign({}, headers), { "sentry-trace": span.toTraceparent() });
      }
    } else {
      headers = { "sentry-trace": span.toTraceparent() };
    }
    options.headers = headers;
  }
}
function xhrCallback(handlerData, shouldCreateSpan, spans) {
  if (!hasTracingEnabled() || handlerData.xhr && handlerData.xhr.__sentry_own_request__ || !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))) {
    return;
  }
  var xhr = handlerData.xhr.__sentry_xhr__;
  if (handlerData.endTimestamp) {
    var spanId = handlerData.xhr.__sentry_xhr_span_id__;
    if (!spanId)
      return;
    var span = spans[spanId];
    if (span) {
      span.setHttpStatus(xhr.status_code);
      span.finish();
      delete spans[spanId];
    }
    return;
  }
  var activeTransaction = getActiveTransaction();
  if (activeTransaction) {
    var span = activeTransaction.startChild({
      data: __assign(__assign({}, xhr.data), { type: "xhr", method: xhr.method, url: xhr.url }),
      description: xhr.method + " " + xhr.url,
      op: "http.client"
    });
    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;
    if (handlerData.xhr.setRequestHeader) {
      try {
        handlerData.xhr.setRequestHeader("sentry-trace", span.toTraceparent());
      } catch (_) {
      }
    }
  }
}

// node_modules/@sentry/tracing/esm/browser/router.js
var global3 = getGlobalObject();
function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
  if (startTransactionOnPageLoad === void 0) {
    startTransactionOnPageLoad = true;
  }
  if (startTransactionOnLocationChange === void 0) {
    startTransactionOnLocationChange = true;
  }
  if (!global3 || !global3.location) {
    IS_DEBUG_BUILD && logger.warn("Could not initialize routing instrumentation due to invalid location");
    return;
  }
  var startingUrl = global3.location.href;
  var activeTransaction;
  if (startTransactionOnPageLoad) {
    activeTransaction = customStartTransaction({ name: global3.location.pathname, op: "pageload" });
  }
  if (startTransactionOnLocationChange) {
    addInstrumentationHandler("history", function(_a) {
      var to = _a.to, from = _a.from;
      if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
        startingUrl = void 0;
        return;
      }
      if (from !== to) {
        startingUrl = void 0;
        if (activeTransaction) {
          IS_DEBUG_BUILD && logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
          activeTransaction.finish();
        }
        activeTransaction = customStartTransaction({ name: global3.location.pathname, op: "navigation" });
      }
    });
  }
}

// node_modules/@sentry/tracing/esm/browser/browsertracing.js
var DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;
var DEFAULT_BROWSER_TRACING_OPTIONS = __assign({ idleTimeout: DEFAULT_IDLE_TIMEOUT, markBackgroundTransactions: true, maxTransactionDuration: DEFAULT_MAX_TRANSACTION_DURATION_SECONDS, routingInstrumentation: instrumentRoutingWithDefaults, startTransactionOnLocationChange: true, startTransactionOnPageLoad: true }, defaultRequestInstrumentationOptions);
var BrowserTracing = function() {
  function BrowserTracing2(_options) {
    this.name = BrowserTracing2.id;
    this._configuredIdleTimeout = void 0;
    var tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins;
    if (_options) {
      this._configuredIdleTimeout = _options.idleTimeout;
      if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins) && _options.tracingOrigins.length !== 0) {
        tracingOrigins = _options.tracingOrigins;
      } else {
        IS_DEBUG_BUILD && (this._emitOptionsWarning = true);
      }
    }
    this.options = __assign(__assign(__assign({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), { tracingOrigins });
    var _metricOptions = this.options._metricOptions;
    this._metrics = new MetricsInstrumentation(_metricOptions && _metricOptions._reportAllChanges);
  }
  BrowserTracing2.prototype.setupOnce = function(_, getCurrentHub2) {
    var _this = this;
    this._getCurrentHub = getCurrentHub2;
    if (this._emitOptionsWarning) {
      IS_DEBUG_BUILD && logger.warn("[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.");
      IS_DEBUG_BUILD && logger.warn("[Tracing] We added a reasonable default for you: " + defaultRequestInstrumentationOptions.tracingOrigins);
    }
    var _a = this.options, instrumentRouting = _a.routingInstrumentation, startTransactionOnLocationChange = _a.startTransactionOnLocationChange, startTransactionOnPageLoad = _a.startTransactionOnPageLoad, markBackgroundTransactions = _a.markBackgroundTransactions, traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
    instrumentRouting(function(context) {
      return _this._createRouteTransaction(context);
    }, startTransactionOnPageLoad, startTransactionOnLocationChange);
    if (markBackgroundTransactions) {
      registerBackgroundTabDetection();
    }
    instrumentOutgoingRequests({ traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest });
  };
  BrowserTracing2.prototype._createRouteTransaction = function(context) {
    var _this = this;
    if (!this._getCurrentHub) {
      IS_DEBUG_BUILD && logger.warn("[Tracing] Did not create " + context.op + " transaction because _getCurrentHub is invalid.");
      return void 0;
    }
    var _a = this.options, beforeNavigate = _a.beforeNavigate, idleTimeout = _a.idleTimeout, maxTransactionDuration = _a.maxTransactionDuration;
    var parentContextFromHeader = context.op === "pageload" ? getHeaderContext() : void 0;
    var expandedContext = __assign(__assign(__assign({}, context), parentContextFromHeader), { trimEnd: true });
    var modifiedContext = typeof beforeNavigate === "function" ? beforeNavigate(expandedContext) : expandedContext;
    var finalContext = modifiedContext === void 0 ? __assign(__assign({}, expandedContext), { sampled: false }) : modifiedContext;
    if (finalContext.sampled === false) {
      IS_DEBUG_BUILD && logger.log("[Tracing] Will not send " + finalContext.op + " transaction because of beforeNavigate.");
    }
    IS_DEBUG_BUILD && logger.log("[Tracing] Starting " + finalContext.op + " transaction on scope");
    var hub = this._getCurrentHub();
    var location = getGlobalObject().location;
    var idleTransaction = startIdleTransaction(hub, finalContext, idleTimeout, true, { location });
    idleTransaction.registerBeforeFinishCallback(function(transaction, endTimestamp) {
      _this._metrics.addPerformanceEntries(transaction);
      adjustTransactionDuration(secToMs(maxTransactionDuration), transaction, endTimestamp);
    });
    idleTransaction.setTag("idleTimeout", this._configuredIdleTimeout);
    return idleTransaction;
  };
  BrowserTracing2.id = "BrowserTracing";
  return BrowserTracing2;
}();
function getHeaderContext() {
  var header = getMetaContent("sentry-trace");
  if (header) {
    return extractTraceparentData(header);
  }
  return void 0;
}
function getMetaContent(metaName) {
  var el = getGlobalObject().document.querySelector("meta[name=" + metaName + "]");
  return el ? el.getAttribute("content") : null;
}
function adjustTransactionDuration(maxDuration, transaction, endTimestamp) {
  var diff = endTimestamp - transaction.startTimestamp;
  var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);
  if (isOutdatedTransaction) {
    transaction.setStatus("deadline_exceeded");
    transaction.setTag("maxTransactionDurationExceeded", "true");
  }
}

// node_modules/@sentry/tracing/esm/spanstatus.js
var SpanStatus;
(function(SpanStatus2) {
  SpanStatus2["Ok"] = "ok";
  SpanStatus2["DeadlineExceeded"] = "deadline_exceeded";
  SpanStatus2["Unauthenticated"] = "unauthenticated";
  SpanStatus2["PermissionDenied"] = "permission_denied";
  SpanStatus2["NotFound"] = "not_found";
  SpanStatus2["ResourceExhausted"] = "resource_exhausted";
  SpanStatus2["InvalidArgument"] = "invalid_argument";
  SpanStatus2["Unimplemented"] = "unimplemented";
  SpanStatus2["Unavailable"] = "unavailable";
  SpanStatus2["InternalError"] = "internal_error";
  SpanStatus2["UnknownError"] = "unknown_error";
  SpanStatus2["Cancelled"] = "cancelled";
  SpanStatus2["AlreadyExists"] = "already_exists";
  SpanStatus2["FailedPrecondition"] = "failed_precondition";
  SpanStatus2["Aborted"] = "aborted";
  SpanStatus2["OutOfRange"] = "out_of_range";
  SpanStatus2["DataLoss"] = "data_loss";
})(SpanStatus || (SpanStatus = {}));

// node_modules/@sentry/tracing/esm/index.js
addExtensionMethods();
export {
  BrowserTracing,
  IdleTransaction,
  integrations_exports as Integrations,
  Span,
  SpanStatus,
  TRACEPARENT_REGEXP,
  Transaction,
  addExtensionMethods,
  defaultRequestInstrumentationOptions,
  extractTraceparentData,
  getActiveTransaction,
  hasTracingEnabled,
  instrumentOutgoingRequests as registerRequestInstrumentation,
  spanStatusfromHttpCode,
  startIdleTransaction,
  stripUrlQueryAndFragment
};
//# sourceMappingURL=@sentry_tracing.js.map

{
  "version": 3,
  "sources": ["../../src/flags.ts", "../../src/utils.ts", "../../src/errors.ts", "../../src/constants.ts", "../../src/span.ts", "../../src/transaction.ts", "../../src/idletransaction.ts", "../../src/hubextensions.ts", "../../src/integrations/index.ts", "../../src/integrations/node/express.ts", "../../src/integrations/node/postgres.ts", "../../src/integrations/node/mysql.ts", "../../src/integrations/node/mongo.ts", "../../src/browser/backgroundtab.ts", "../../src/browser/web-vitals/lib/bindReporter.ts", "../../src/browser/web-vitals/lib/generateUniqueID.ts", "../../src/browser/web-vitals/lib/initMetric.ts", "../../src/browser/web-vitals/lib/observe.ts", "../../src/browser/web-vitals/lib/onHidden.ts", "../../src/browser/web-vitals/getCLS.ts", "../../src/browser/web-vitals/lib/getVisibilityWatcher.ts", "../../src/browser/web-vitals/getFID.ts", "../../src/browser/web-vitals/getLCP.ts", "../../src/browser/metrics.ts", "../../src/browser/request.ts", "../../src/browser/router.ts", "../../src/browser/browsertracing.ts", "../../src/spanstatus.ts", "../../src/index.ts"],
  "sourcesContent": ["/*\n * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking\n * for users.\n *\n * Debug flags need to be declared in each package individually and must not be imported across package boundaries,\n * because some build tools have trouble tree-shaking imported guards.\n *\n * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.\n *\n * Debug flag files will contain \"magic strings\" like `__SENTRY_DEBUG__` that may get replaced with actual values during\n * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not\n * replaced.\n */\n\ndeclare const __SENTRY_DEBUG__: boolean;\n\n/** Flag that is true for debug builds, false otherwise. */\nexport const IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;\n", "import { getCurrentHub, Hub } from '@sentry/hub';\nimport { Options, Transaction } from '@sentry/types';\n\n/**\n * The `extractTraceparentData` function and `TRACEPARENT_REGEXP` constant used\n * to be declared in this file. It was later moved into `@sentry/utils` as part of a\n * move to remove `@sentry/tracing` dependencies from `@sentry/node` (`extractTraceparentData`\n * is the only tracing function used by `@sentry/node`).\n *\n * These exports are kept here for backwards compatability's sake.\n *\n * TODO(v7): Reorganize these exports\n *\n * See https://github.com/getsentry/sentry-javascript/issues/4642 for more details.\n */\nexport { TRACEPARENT_REGEXP, extractTraceparentData } from '@sentry/utils';\n\n/**\n * Determines if tracing is currently enabled.\n *\n * Tracing is enabled when at least one of `tracesSampleRate` and `tracesSampler` is defined in the SDK config.\n */\nexport function hasTracingEnabled(maybeOptions?: Options | undefined): boolean {\n  const client = getCurrentHub().getClient();\n  const options = maybeOptions || (client && client.getOptions());\n  return !!options && ('tracesSampleRate' in options || 'tracesSampler' in options);\n}\n\n/** Grabs active transaction off scope, if any */\nexport function getActiveTransaction<T extends Transaction>(maybeHub?: Hub): T | undefined {\n  const hub = maybeHub || getCurrentHub();\n  const scope = hub.getScope();\n  return scope && (scope.getTransaction() as T | undefined);\n}\n\n/**\n * Converts from milliseconds to seconds\n * @param time time in ms\n */\nexport function msToSec(time: number): number {\n  return time / 1000;\n}\n\n/**\n * Converts from seconds to milliseconds\n * @param time time in seconds\n */\nexport function secToMs(time: number): number {\n  return time * 1000;\n}\n\n// so it can be used in manual instrumentation without necessitating a hard dependency on @sentry/utils\nexport { stripUrlQueryAndFragment } from '@sentry/utils';\n", "import { addInstrumentationHandler, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { SpanStatusType } from './span';\nimport { getActiveTransaction } from './utils';\n\n/**\n * Configures global error listeners\n */\nexport function registerErrorInstrumentation(): void {\n  addInstrumentationHandler('error', errorCallback);\n  addInstrumentationHandler('unhandledrejection', errorCallback);\n}\n\n/**\n * If an error or unhandled promise occurs, we mark the active transaction as failed\n */\nfunction errorCallback(): void {\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const status: SpanStatusType = 'internal_error';\n    IS_DEBUG_BUILD && logger.log(`[Tracing] Transaction: ${status} -> Global error occured`);\n    activeTransaction.setStatus(status);\n  }\n}\n", "// Store finish reasons in tuple to save on bundle size\n// Readonly type should enforce that this is not mutated.\nexport const FINISH_REASON_TAG = 'finishReason';\n\nexport const IDLE_TRANSACTION_FINISH_REASONS = ['heartbeatFailed', 'idleTimeout', 'documentHidden'] as const;\n", "/* eslint-disable max-lines */\nimport { Primitive, Span as SpanInterface, SpanContext, Transaction } from '@sentry/types';\nimport { dropUndefinedKeys, timestampWithMs, uuid4 } from '@sentry/utils';\n\n/**\n * Keeps track of finished spans for a given transaction\n * @internal\n * @hideconstructor\n * @hidden\n */\nexport class SpanRecorder {\n  public spans: Span[] = [];\n\n  private readonly _maxlen: number;\n\n  public constructor(maxlen: number = 1000) {\n    this._maxlen = maxlen;\n  }\n\n  /**\n   * This is just so that we don't run out of memory while recording a lot\n   * of spans. At some point we just stop and flush out the start of the\n   * trace tree (i.e.the first n spans with the smallest\n   * start_timestamp).\n   */\n  public add(span: Span): void {\n    if (this.spans.length > this._maxlen) {\n      span.spanRecorder = undefined;\n    } else {\n      this.spans.push(span);\n    }\n  }\n}\n\n/**\n * Span contains all data about a span\n */\nexport class Span implements SpanInterface {\n  /**\n   * @inheritDoc\n   */\n  public traceId: string = uuid4();\n\n  /**\n   * @inheritDoc\n   */\n  public spanId: string = uuid4().substring(16);\n\n  /**\n   * @inheritDoc\n   */\n  public parentSpanId?: string;\n\n  /**\n   * Internal keeper of the status\n   */\n  public status?: SpanStatusType | string;\n\n  /**\n   * @inheritDoc\n   */\n  public sampled?: boolean;\n\n  /**\n   * Timestamp in seconds when the span was created.\n   */\n  public startTimestamp: number = timestampWithMs();\n\n  /**\n   * Timestamp in seconds when the span ended.\n   */\n  public endTimestamp?: number;\n\n  /**\n   * @inheritDoc\n   */\n  public op?: string;\n\n  /**\n   * @inheritDoc\n   */\n  public description?: string;\n\n  /**\n   * @inheritDoc\n   */\n  public tags: { [key: string]: Primitive } = {};\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public data: { [key: string]: any } = {};\n\n  /**\n   * List of spans that were finalized\n   */\n  public spanRecorder?: SpanRecorder;\n\n  /**\n   * @inheritDoc\n   */\n  public transaction?: Transaction;\n\n  /**\n   * You should never call the constructor manually, always use `Sentry.startTransaction()`\n   * or call `startChild()` on an existing span.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  public constructor(spanContext?: SpanContext) {\n    if (!spanContext) {\n      return this;\n    }\n    if (spanContext.traceId) {\n      this.traceId = spanContext.traceId;\n    }\n    if (spanContext.spanId) {\n      this.spanId = spanContext.spanId;\n    }\n    if (spanContext.parentSpanId) {\n      this.parentSpanId = spanContext.parentSpanId;\n    }\n    // We want to include booleans as well here\n    if ('sampled' in spanContext) {\n      this.sampled = spanContext.sampled;\n    }\n    if (spanContext.op) {\n      this.op = spanContext.op;\n    }\n    if (spanContext.description) {\n      this.description = spanContext.description;\n    }\n    if (spanContext.data) {\n      this.data = spanContext.data;\n    }\n    if (spanContext.tags) {\n      this.tags = spanContext.tags;\n    }\n    if (spanContext.status) {\n      this.status = spanContext.status;\n    }\n    if (spanContext.startTimestamp) {\n      this.startTimestamp = spanContext.startTimestamp;\n    }\n    if (spanContext.endTimestamp) {\n      this.endTimestamp = spanContext.endTimestamp;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   * @deprecated\n   */\n  public child(\n    spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>,\n  ): Span {\n    return this.startChild(spanContext);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public startChild(\n    spanContext?: Pick<SpanContext, Exclude<keyof SpanContext, 'spanId' | 'sampled' | 'traceId' | 'parentSpanId'>>,\n  ): Span {\n    const childSpan = new Span({\n      ...spanContext,\n      parentSpanId: this.spanId,\n      sampled: this.sampled,\n      traceId: this.traceId,\n    });\n\n    childSpan.spanRecorder = this.spanRecorder;\n    if (childSpan.spanRecorder) {\n      childSpan.spanRecorder.add(childSpan);\n    }\n\n    childSpan.transaction = this.transaction;\n\n    return childSpan;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setTag(key: string, value: Primitive): this {\n    this.tags = { ...this.tags, [key]: value };\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public setData(key: string, value: any): this {\n    this.data = { ...this.data, [key]: value };\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setStatus(value: SpanStatusType): this {\n    this.status = value;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setHttpStatus(httpStatus: number): this {\n    this.setTag('http.status_code', String(httpStatus));\n    const spanStatus = spanStatusfromHttpCode(httpStatus);\n    if (spanStatus !== 'unknown_error') {\n      this.setStatus(spanStatus);\n    }\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public isSuccess(): boolean {\n    return this.status === 'ok';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public finish(endTimestamp?: number): void {\n    this.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public toTraceparent(): string {\n    let sampledString = '';\n    if (this.sampled !== undefined) {\n      sampledString = this.sampled ? '-1' : '-0';\n    }\n    return `${this.traceId}-${this.spanId}${sampledString}`;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public toContext(): SpanContext {\n    return dropUndefinedKeys({\n      data: this.data,\n      description: this.description,\n      endTimestamp: this.endTimestamp,\n      op: this.op,\n      parentSpanId: this.parentSpanId,\n      sampled: this.sampled,\n      spanId: this.spanId,\n      startTimestamp: this.startTimestamp,\n      status: this.status,\n      tags: this.tags,\n      traceId: this.traceId,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public updateWithContext(spanContext: SpanContext): this {\n    this.data = spanContext.data ?? {};\n    this.description = spanContext.description;\n    this.endTimestamp = spanContext.endTimestamp;\n    this.op = spanContext.op;\n    this.parentSpanId = spanContext.parentSpanId;\n    this.sampled = spanContext.sampled;\n    this.spanId = spanContext.spanId ?? this.spanId;\n    this.startTimestamp = spanContext.startTimestamp ?? this.startTimestamp;\n    this.status = spanContext.status;\n    this.tags = spanContext.tags ?? {};\n    this.traceId = spanContext.traceId ?? this.traceId;\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTraceContext(): {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data?: { [key: string]: any };\n    description?: string;\n    op?: string;\n    parent_span_id?: string;\n    span_id: string;\n    status?: string;\n    tags?: { [key: string]: Primitive };\n    trace_id: string;\n  } {\n    return dropUndefinedKeys({\n      data: Object.keys(this.data).length > 0 ? this.data : undefined,\n      description: this.description,\n      op: this.op,\n      parent_span_id: this.parentSpanId,\n      span_id: this.spanId,\n      status: this.status,\n      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,\n      trace_id: this.traceId,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public toJSON(): {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data?: { [key: string]: any };\n    description?: string;\n    op?: string;\n    parent_span_id?: string;\n    span_id: string;\n    start_timestamp: number;\n    status?: string;\n    tags?: { [key: string]: Primitive };\n    timestamp?: number;\n    trace_id: string;\n  } {\n    return dropUndefinedKeys({\n      data: Object.keys(this.data).length > 0 ? this.data : undefined,\n      description: this.description,\n      op: this.op,\n      parent_span_id: this.parentSpanId,\n      span_id: this.spanId,\n      start_timestamp: this.startTimestamp,\n      status: this.status,\n      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,\n      timestamp: this.endTimestamp,\n      trace_id: this.traceId,\n    });\n  }\n}\n\nexport type SpanStatusType =\n  /** The operation completed successfully. */\n  | 'ok'\n  /** Deadline expired before operation could complete. */\n  | 'deadline_exceeded'\n  /** 401 Unauthorized (actually does mean unauthenticated according to RFC 7235) */\n  | 'unauthenticated'\n  /** 403 Forbidden */\n  | 'permission_denied'\n  /** 404 Not Found. Some requested entity (file or directory) was not found. */\n  | 'not_found'\n  /** 429 Too Many Requests */\n  | 'resource_exhausted'\n  /** Client specified an invalid argument. 4xx. */\n  | 'invalid_argument'\n  /** 501 Not Implemented */\n  | 'unimplemented'\n  /** 503 Service Unavailable */\n  | 'unavailable'\n  /** Other/generic 5xx. */\n  | 'internal_error'\n  /** Unknown. Any non-standard HTTP status code. */\n  | 'unknown_error'\n  /** The operation was cancelled (typically by the user). */\n  | 'cancelled'\n  /** Already exists (409) */\n  | 'already_exists'\n  /** Operation was rejected because the system is not in a state required for the operation's */\n  | 'failed_precondition'\n  /** The operation was aborted, typically due to a concurrency issue. */\n  | 'aborted'\n  /** Operation was attempted past the valid range. */\n  | 'out_of_range'\n  /** Unrecoverable data loss or corruption */\n  | 'data_loss';\n\n/**\n * Converts a HTTP status code into a {@link SpanStatusType}.\n *\n * @param httpStatus The HTTP response status code.\n * @returns The span status or unknown_error.\n */\nexport function spanStatusfromHttpCode(httpStatus: number): SpanStatusType {\n  if (httpStatus < 400 && httpStatus >= 100) {\n    return 'ok';\n  }\n\n  if (httpStatus >= 400 && httpStatus < 500) {\n    switch (httpStatus) {\n      case 401:\n        return 'unauthenticated';\n      case 403:\n        return 'permission_denied';\n      case 404:\n        return 'not_found';\n      case 409:\n        return 'already_exists';\n      case 413:\n        return 'failed_precondition';\n      case 429:\n        return 'resource_exhausted';\n      default:\n        return 'invalid_argument';\n    }\n  }\n\n  if (httpStatus >= 500 && httpStatus < 600) {\n    switch (httpStatus) {\n      case 501:\n        return 'unimplemented';\n      case 503:\n        return 'unavailable';\n      case 504:\n        return 'deadline_exceeded';\n      default:\n        return 'internal_error';\n    }\n  }\n\n  return 'unknown_error';\n}\n", "import { getCurrentHub, Hub } from '@sentry/hub';\nimport {\n  Event,\n  Measurements,\n  Transaction as TransactionInterface,\n  TransactionContext,\n  TransactionMetadata,\n} from '@sentry/types';\nimport { dropUndefinedKeys, isInstanceOf, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { Span as SpanClass, SpanRecorder } from './span';\n\n/** JSDoc */\nexport class Transaction extends SpanClass implements TransactionInterface {\n  public name: string;\n\n  public metadata: TransactionMetadata;\n\n  private _measurements: Measurements = {};\n\n  /**\n   * The reference to the current hub.\n   */\n  private readonly _hub: Hub = getCurrentHub() as unknown as Hub;\n\n  private _trimEnd?: boolean;\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  public constructor(transactionContext: TransactionContext, hub?: Hub) {\n    super(transactionContext);\n\n    if (isInstanceOf(hub, Hub)) {\n      this._hub = hub as Hub;\n    }\n\n    this.name = transactionContext.name || '';\n\n    this.metadata = transactionContext.metadata || {};\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n  }\n\n  /**\n   * JSDoc\n   */\n  public setName(name: string): void {\n    this.name = name;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  public initSpanRecorder(maxlen: number = 1000): void {\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Set observed measurements for this transaction.\n   * @hidden\n   */\n  public setMeasurements(measurements: Measurements): void {\n    this._measurements = { ...measurements };\n  }\n\n  /**\n   * Set metadata for this transaction.\n   * @hidden\n   */\n  public setMetadata(newMetadata: TransactionMetadata): void {\n    this.metadata = { ...this.metadata, ...newMetadata };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public finish(endTimestamp?: number): string | undefined {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      IS_DEBUG_BUILD && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      IS_DEBUG_BUILD && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n\n      const client = this._hub.getClient();\n      const transport = client && client.getTransport && client.getTransport();\n      if (transport && transport.recordLostEvent) {\n        transport.recordLostEvent('sample_rate', 'transaction');\n      }\n      return undefined;\n    }\n\n    const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev: SpanClass, current: SpanClass) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n\n    const transaction: Event = {\n      contexts: {\n        trace: this.getTraceContext(),\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n      sdkProcessingMetadata: this.metadata,\n    };\n\n    const hasMeasurements = Object.keys(this._measurements).length > 0;\n\n    if (hasMeasurements) {\n      IS_DEBUG_BUILD &&\n        logger.log(\n          '[Measurements] Adding measurements to transaction',\n          JSON.stringify(this._measurements, undefined, 2),\n        );\n      transaction.measurements = this._measurements;\n    }\n\n    IS_DEBUG_BUILD && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);\n\n    return this._hub.captureEvent(transaction);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public toContext(): TransactionContext {\n    const spanContext = super.toContext();\n\n    return dropUndefinedKeys({\n      ...spanContext,\n      name: this.name,\n      trimEnd: this._trimEnd,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public updateWithContext(transactionContext: TransactionContext): this {\n    super.updateWithContext(transactionContext);\n\n    this.name = transactionContext.name ?? '';\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    return this;\n  }\n}\n", "import { Hub } from '@sentry/hub';\nimport { TransactionContext } from '@sentry/types';\nimport { logger, timestampWithMs } from '@sentry/utils';\n\nimport { FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS } from './constants';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { Span, SpanRecorder } from './span';\nimport { Transaction } from './transaction';\n\nexport const DEFAULT_IDLE_TIMEOUT = 1000;\nexport const HEARTBEAT_INTERVAL = 5000;\n\n/**\n * @inheritDoc\n */\nexport class IdleTransactionSpanRecorder extends SpanRecorder {\n  public constructor(\n    private readonly _pushActivity: (id: string) => void,\n    private readonly _popActivity: (id: string) => void,\n    public transactionSpanId: string = '',\n    maxlen?: number,\n  ) {\n    super(maxlen);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(span: Span): void {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp?: number) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\nexport type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nexport class IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  public activities: Record<string, boolean> = {};\n\n  // Track state of activities in previous heartbeat\n  private _prevHeartbeatString: string | undefined;\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  private _heartbeatCounter: number = 0;\n\n  // We should not use heartbeat if we finished a transaction\n  private _finished: boolean = false;\n\n  private readonly _beforeFinishCallbacks: BeforeFinishCallback[] = [];\n\n  /**\n   * If a transaction is created and no activities are added, we want to make sure that\n   * it times out properly. This is cleared and not used when activities are added.\n   */\n  private _initTimeout: ReturnType<typeof setTimeout> | undefined;\n\n  public constructor(\n    transactionContext: TransactionContext,\n    private readonly _idleHub?: Hub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished.\n     * @default 1000\n     */\n    private readonly _idleTimeout: number = DEFAULT_IDLE_TIMEOUT,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n    private readonly _onScope: boolean = false,\n  ) {\n    super(transactionContext, _idleHub);\n\n    if (_idleHub && _onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      IS_DEBUG_BUILD && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._initTimeout = setTimeout(() => {\n      if (!this._finished) {\n        this.finish();\n      }\n    }, this._idleTimeout);\n  }\n\n  /** {@inheritDoc} */\n  public finish(endTimestamp: number = timestampWithMs()): string | undefined {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      IS_DEBUG_BUILD &&\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span: Span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          IS_DEBUG_BUILD &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          IS_DEBUG_BUILD &&\n            logger.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      IS_DEBUG_BUILD && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      IS_DEBUG_BUILD && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  public registerBeforeFinishCallback(callback: BeforeFinishCallback): void {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public initSpanRecorder(maxlen?: number): void {\n    if (!this.spanRecorder) {\n      const pushActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      IS_DEBUG_BUILD && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  private _pushActivity(spanId: string): void {\n    if (this._initTimeout) {\n      clearTimeout(this._initTimeout);\n      this._initTimeout = undefined;\n    }\n    IS_DEBUG_BUILD && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    IS_DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  private _popActivity(spanId: string): void {\n    if (this.activities[spanId]) {\n      IS_DEBUG_BUILD && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      IS_DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      const timeout = this._idleTimeout;\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      const end = timestampWithMs() + timeout / 1000;\n\n      setTimeout(() => {\n        if (!this._finished) {\n          this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[1]);\n          this.finish(end);\n        }\n      }, timeout);\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  private _beat(): void {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter += 1;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      IS_DEBUG_BUILD && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[0]);\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  private _pingHeartbeat(): void {\n    IS_DEBUG_BUILD && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, HEARTBEAT_INTERVAL);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub?: Hub): void {\n  if (hub) {\n    const scope = hub.getScope();\n    if (scope) {\n      const transaction = scope.getTransaction();\n      if (transaction) {\n        scope.setSpan(undefined);\n      }\n    }\n  }\n}\n", "import { getMainCarrier, Hub } from '@sentry/hub';\nimport {\n  CustomSamplingContext,\n  Integration,\n  IntegrationClass,\n  Options,\n  SamplingContext,\n  TransactionContext,\n} from '@sentry/types';\nimport { dynamicRequire, isNaN, isNodeEnv, loadModule, logger } from '@sentry/utils';\n\nimport { registerErrorInstrumentation } from './errors';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { IdleTransaction } from './idletransaction';\nimport { Transaction } from './transaction';\nimport { hasTracingEnabled } from './utils';\n\n/** Returns all trace headers that are currently on the top scope. */\nfunction traceHeaders(this: Hub): { [key: string]: string } {\n  const scope = this.getScope();\n  if (scope) {\n    const span = scope.getSpan();\n    if (span) {\n      return {\n        'sentry-trace': span.toTraceparent(),\n      };\n    }\n  }\n  return {};\n}\n\n/**\n * Makes a sampling decision for the given transaction and stores it on the transaction.\n *\n * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n *\n * @param transaction: The transaction needing a sampling decision\n * @param options: The current client's options, so we can access `tracesSampleRate` and/or `tracesSampler`\n * @param samplingContext: Default and user-provided data which may be used to help make the decision\n *\n * @returns The given transaction with its `sampled` value set\n */\nfunction sample<T extends Transaction>(transaction: T, options: Options, samplingContext: SamplingContext): T {\n  // nothing to do if tracing is not enabled\n  if (!hasTracingEnabled(options)) {\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that\n  if (transaction.sampled !== undefined) {\n    transaction.setMetadata({\n      transactionSampling: { method: 'explicitly_set' },\n    });\n    return transaction;\n  }\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler(samplingContext);\n    transaction.setMetadata({\n      transactionSampling: {\n        method: 'client_sampler',\n        // cast to number in case it's a boolean\n        rate: Number(sampleRate),\n      },\n    });\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n    transaction.setMetadata({\n      transactionSampling: { method: 'inheritance' },\n    });\n  } else {\n    sampleRate = options.tracesSampleRate;\n    transaction.setMetadata({\n      transactionSampling: {\n        method: 'client_rate',\n        // cast to number in case it's a boolean\n        rate: Number(sampleRate),\n      },\n    });\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(sampleRate)) {\n    IS_DEBUG_BUILD && logger.warn('[Tracing] Discarding transaction because of invalid sample rate.');\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!sampleRate) {\n    IS_DEBUG_BUILD &&\n      logger.log(\n        `[Tracing] Discarding transaction because ${\n          typeof options.tracesSampler === 'function'\n            ? 'tracesSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'\n        }`,\n      );\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  transaction.sampled = Math.random() < (sampleRate as number | boolean);\n\n  // if we're not going to keep it, we're done\n  if (!transaction.sampled) {\n    IS_DEBUG_BUILD &&\n      logger.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate,\n        )})`,\n      );\n    return transaction;\n  }\n\n  IS_DEBUG_BUILD && logger.log(`[Tracing] starting ${transaction.op} transaction - ${transaction.name}`);\n  return transaction;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate: unknown): boolean {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if (isNaN(rate) || !(typeof rate === 'number' || typeof rate === 'boolean')) {\n    IS_DEBUG_BUILD &&\n      logger.warn(\n        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    IS_DEBUG_BUILD &&\n      logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a new transaction and adds a sampling decision if it doesn't yet have one.\n *\n * The Hub.startTransaction method delegates to this method to do its work, passing the Hub instance in as `this`, as if\n * it had been called on the hub directly. Exists as a separate function so that it can be injected into the class as an\n * \"extension method.\"\n *\n * @param this: The Hub starting the transaction\n * @param transactionContext: Data used to configure the transaction\n * @param CustomSamplingContext: Optional data to be provided to the `tracesSampler` function (if any)\n *\n * @returns The new transaction\n *\n * @see {@link Hub.startTransaction}\n */\nfunction _startTransaction(\n  this: Hub,\n  transactionContext: TransactionContext,\n  customSamplingContext?: CustomSamplingContext,\n): Transaction {\n  const client = this.getClient();\n  const options = (client && client.getOptions()) || {};\n\n  let transaction = new Transaction(transactionContext, this);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans as number));\n  }\n  return transaction;\n}\n\n/**\n * Create new idle transaction.\n */\nexport function startIdleTransaction(\n  hub: Hub,\n  transactionContext: TransactionContext,\n  idleTimeout?: number,\n  onScope?: boolean,\n  customSamplingContext?: CustomSamplingContext,\n): IdleTransaction {\n  const client = hub.getClient();\n  const options = (client && client.getOptions()) || {};\n\n  let transaction = new IdleTransaction(transactionContext, hub, idleTimeout, onScope);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans as number));\n  }\n  return transaction;\n}\n\n/**\n * @private\n */\nexport function _addTracingExtensions(): void {\n  const carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n  if (!carrier.__SENTRY__.extensions.startTransaction) {\n    carrier.__SENTRY__.extensions.startTransaction = _startTransaction;\n  }\n  if (!carrier.__SENTRY__.extensions.traceHeaders) {\n    carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n  }\n}\n\n/**\n * @private\n */\nfunction _autoloadDatabaseIntegrations(): void {\n  const carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n\n  const packageToIntegrationMapping: Record<string, () => Integration> = {\n    mongodb() {\n      const integration = dynamicRequire(module, './integrations/node/mongo') as {\n        Mongo: IntegrationClass<Integration>;\n      };\n      return new integration.Mongo();\n    },\n    mongoose() {\n      const integration = dynamicRequire(module, './integrations/node/mongo') as {\n        Mongo: IntegrationClass<Integration>;\n      };\n      return new integration.Mongo({ mongoose: true });\n    },\n    mysql() {\n      const integration = dynamicRequire(module, './integrations/node/mysql') as {\n        Mysql: IntegrationClass<Integration>;\n      };\n      return new integration.Mysql();\n    },\n    pg() {\n      const integration = dynamicRequire(module, './integrations/node/postgres') as {\n        Postgres: IntegrationClass<Integration>;\n      };\n      return new integration.Postgres();\n    },\n  };\n\n  const mappedPackages = Object.keys(packageToIntegrationMapping)\n    .filter(moduleName => !!loadModule(moduleName))\n    .map(pkg => {\n      try {\n        return packageToIntegrationMapping[pkg]();\n      } catch (e) {\n        return undefined;\n      }\n    })\n    .filter(p => p) as Integration[];\n\n  if (mappedPackages.length > 0) {\n    carrier.__SENTRY__.integrations = [...(carrier.__SENTRY__.integrations || []), ...mappedPackages];\n  }\n}\n\n/**\n * This patches the global object and injects the Tracing extensions methods\n */\nexport function addExtensionMethods(): void {\n  _addTracingExtensions();\n\n  // Detect and automatically load specified integrations.\n  if (isNodeEnv()) {\n    _autoloadDatabaseIntegrations();\n  }\n\n  // If an error happens globally, we should make sure transaction status is set to error.\n  registerErrorInstrumentation();\n}\n", "export { Express } from './node/express';\nexport { Postgres } from './node/postgres';\nexport { Mysql } from './node/mysql';\nexport { Mongo } from './node/mongo';\n\n// TODO(v7): Remove this export\n// Please see `src/index.ts` for more details.\nexport { BrowserTracing } from '../browser';\n", "import { Integration, Transaction } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../../flags';\n\ntype Method =\n  | 'all'\n  | 'get'\n  | 'post'\n  | 'put'\n  | 'delete'\n  | 'patch'\n  | 'options'\n  | 'head'\n  | 'checkout'\n  | 'copy'\n  | 'lock'\n  | 'merge'\n  | 'mkactivity'\n  | 'mkcol'\n  | 'move'\n  | 'm-search'\n  | 'notify'\n  | 'purge'\n  | 'report'\n  | 'search'\n  | 'subscribe'\n  | 'trace'\n  | 'unlock'\n  | 'unsubscribe'\n  | 'use';\n\ntype Router = {\n  [method in Method]: (...args: any) => any; // eslint-disable-line @typescript-eslint/no-explicit-any\n};\n\ninterface ExpressResponse {\n  once(name: string, callback: () => void): void;\n}\n\n/**\n * Internal helper for `__sentry_transaction`\n * @hidden\n */\ninterface SentryTracingResponse {\n  __sentry_transaction?: Transaction;\n}\n\n/**\n * Express integration\n *\n * Provides an request and error handler for Express framework as well as tracing capabilities\n */\nexport class Express implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Express';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Express.id;\n\n  /**\n   * Express App instance\n   */\n  private readonly _router?: Router;\n  private readonly _methods?: Method[];\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { app?: Router; router?: Router; methods?: Method[] } = {}) {\n    this._router = options.router || options.app;\n    this._methods = (Array.isArray(options.methods) ? options.methods : []).concat('use');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    if (!this._router) {\n      IS_DEBUG_BUILD && logger.error('ExpressIntegration is missing an Express instance');\n      return;\n    }\n    instrumentMiddlewares(this._router, this._methods);\n  }\n}\n\n/**\n * Wraps original middleware function in a tracing call, which stores the info about the call as a span,\n * and finishes it once the middleware is done invoking.\n *\n * Express middlewares have 3 various forms, thus we have to take care of all of them:\n * // sync\n * app.use(function (req, res) { ... })\n * // async\n * app.use(function (req, res, next) { ... })\n * // error handler\n * app.use(function (err, req, res, next) { ... })\n *\n * They all internally delegate to the `router[method]` of the given application instance.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\nfunction wrap(fn: Function, method: Method): (...args: any[]) => void {\n  const arity = fn.length;\n\n  switch (arity) {\n    case 2: {\n      return function (this: NodeJS.Global, req: unknown, res: ExpressResponse & SentryTracingResponse): void {\n        const transaction = res.__sentry_transaction;\n        if (transaction) {\n          const span = transaction.startChild({\n            description: fn.name,\n            op: `express.middleware.${method}`,\n          });\n          res.once('finish', () => {\n            span.finish();\n          });\n        }\n        return fn.call(this, req, res);\n      };\n    }\n    case 3: {\n      return function (\n        this: NodeJS.Global,\n        req: unknown,\n        res: ExpressResponse & SentryTracingResponse,\n        next: () => void,\n      ): void {\n        const transaction = res.__sentry_transaction;\n        const span = transaction?.startChild({\n          description: fn.name,\n          op: `express.middleware.${method}`,\n        });\n        fn.call(this, req, res, function (this: NodeJS.Global, ...args: unknown[]): void {\n          span?.finish();\n          next.call(this, ...args);\n        });\n      };\n    }\n    case 4: {\n      return function (\n        this: NodeJS.Global,\n        err: Error,\n        req: Request,\n        res: Response & SentryTracingResponse,\n        next: () => void,\n      ): void {\n        const transaction = res.__sentry_transaction;\n        const span = transaction?.startChild({\n          description: fn.name,\n          op: `express.middleware.${method}`,\n        });\n        fn.call(this, err, req, res, function (this: NodeJS.Global, ...args: unknown[]): void {\n          span?.finish();\n          next.call(this, ...args);\n        });\n      };\n    }\n    default: {\n      throw new Error(`Express middleware takes 2-4 arguments. Got: ${arity}`);\n    }\n  }\n}\n\n/**\n * Takes all the function arguments passed to the original `app` or `router` method, eg. `app.use` or `router.use`\n * and wraps every function, as well as array of functions with a call to our `wrap` method.\n * We have to take care of the arrays as well as iterate over all of the arguments,\n * as `app.use` can accept middlewares in few various forms.\n *\n * app.use([<path>], <fn>)\n * app.use([<path>], <fn>, ...<fn>)\n * app.use([<path>], ...<fn>[])\n */\nfunction wrapMiddlewareArgs(args: unknown[], method: Method): unknown[] {\n  return args.map((arg: unknown) => {\n    if (typeof arg === 'function') {\n      return wrap(arg, method);\n    }\n\n    if (Array.isArray(arg)) {\n      return arg.map((a: unknown) => {\n        if (typeof a === 'function') {\n          return wrap(a, method);\n        }\n        return a;\n      });\n    }\n\n    return arg;\n  });\n}\n\n/**\n * Patches original router to utilize our tracing functionality\n */\nfunction patchMiddleware(router: Router, method: Method): Router {\n  const originalCallback = router[method];\n\n  router[method] = function (...args: unknown[]): void {\n    return originalCallback.call(this, ...wrapMiddlewareArgs(args, method));\n  };\n\n  return router;\n}\n\n/**\n * Patches original router methods\n */\nfunction instrumentMiddlewares(router: Router, methods: Method[] = []): void {\n  methods.forEach((method: Method) => patchMiddleware(router, method));\n}\n", "import { Hub } from '@sentry/hub';\nimport { EventProcessor, Integration } from '@sentry/types';\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../../flags';\n\ninterface PgClient {\n  prototype: {\n    query: () => void | Promise<unknown>;\n  };\n}\n\ninterface PgOptions {\n  usePgNative?: boolean;\n}\n\n/** Tracing integration for node-postgres package */\nexport class Postgres implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Postgres';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Postgres.id;\n\n  private _usePgNative: boolean;\n\n  public constructor(options: PgOptions = {}) {\n    this._usePgNative = !!options.usePgNative;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    const pkg = loadModule<{ Client: PgClient; native: { Client: PgClient } }>('pg');\n\n    if (!pkg) {\n      IS_DEBUG_BUILD && logger.error('Postgres Integration was unable to require `pg` package.');\n      return;\n    }\n\n    if (this._usePgNative && !pkg.native?.Client) {\n      IS_DEBUG_BUILD && logger.error(\"Postgres Integration was unable to access 'pg-native' bindings.\");\n      return;\n    }\n\n    const { Client } = this._usePgNative ? pkg.native : pkg;\n\n    /**\n     * function (query, callback) => void\n     * function (query, params, callback) => void\n     * function (query) => Promise\n     * function (query, params) => Promise\n     * function (pg.Cursor) => pg.Cursor\n     */\n    fill(Client.prototype, 'query', function (orig: () => void | Promise<unknown>) {\n      return function (this: unknown, config: unknown, values: unknown, callback: unknown) {\n        const scope = getCurrentHub().getScope();\n        const parentSpan = scope?.getSpan();\n        const span = parentSpan?.startChild({\n          description: typeof config === 'string' ? config : (config as { text: string }).text,\n          op: 'db',\n        });\n\n        if (typeof callback === 'function') {\n          return orig.call(this, config, values, function (err: Error, result: unknown) {\n            span?.finish();\n            callback(err, result);\n          });\n        }\n\n        if (typeof values === 'function') {\n          return orig.call(this, config, function (err: Error, result: unknown) {\n            span?.finish();\n            values(err, result);\n          });\n        }\n\n        const rv = typeof values !== 'undefined' ? orig.call(this, config, values) : orig.call(this, config);\n\n        if (isThenable(rv)) {\n          return rv.then((res: unknown) => {\n            span?.finish();\n            return res;\n          });\n        }\n\n        span?.finish();\n        return rv;\n      };\n    });\n  }\n}\n", "import { Hub } from '@sentry/hub';\nimport { EventProcessor, Integration } from '@sentry/types';\nimport { fill, loadModule, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../../flags';\n\ninterface MysqlConnection {\n  createQuery: () => void;\n}\n\n/** Tracing integration for node-mysql package */\nexport class Mysql implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Mysql';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Mysql.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    const pkg = loadModule<MysqlConnection>('mysql/lib/Connection.js');\n\n    if (!pkg) {\n      IS_DEBUG_BUILD && logger.error('Mysql Integration was unable to require `mysql` package.');\n      return;\n    }\n\n    // The original function will have one of these signatures:\n    //    function (callback) => void\n    //    function (options, callback) => void\n    //    function (options, values, callback) => void\n    fill(pkg, 'createQuery', function (orig: () => void) {\n      return function (this: unknown, options: unknown, values: unknown, callback: unknown) {\n        const scope = getCurrentHub().getScope();\n        const parentSpan = scope?.getSpan();\n        const span = parentSpan?.startChild({\n          description: typeof options === 'string' ? options : (options as { sql: string }).sql,\n          op: 'db',\n        });\n\n        if (typeof callback === 'function') {\n          return orig.call(this, options, values, function (err: Error, result: unknown, fields: unknown) {\n            span?.finish();\n            callback(err, result, fields);\n          });\n        }\n\n        if (typeof values === 'function') {\n          return orig.call(this, options, function (err: Error, result: unknown, fields: unknown) {\n            span?.finish();\n            values(err, result, fields);\n          });\n        }\n\n        return orig.call(this, options, values, callback);\n      };\n    });\n  }\n}\n", "import { Hub } from '@sentry/hub';\nimport { EventProcessor, Integration, SpanContext } from '@sentry/types';\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../../flags';\n\n// This allows us to use the same array for both defaults options and the type itself.\n// (note `as const` at the end to make it a union of string literal types (i.e. \"a\" | \"b\" | ... )\n// and not just a string[])\ntype Operation = typeof OPERATIONS[number];\nconst OPERATIONS = [\n  'aggregate', // aggregate(pipeline, options, callback)\n  'bulkWrite', // bulkWrite(operations, options, callback)\n  'countDocuments', // countDocuments(query, options, callback)\n  'createIndex', // createIndex(fieldOrSpec, options, callback)\n  'createIndexes', // createIndexes(indexSpecs, options, callback)\n  'deleteMany', // deleteMany(filter, options, callback)\n  'deleteOne', // deleteOne(filter, options, callback)\n  'distinct', // distinct(key, query, options, callback)\n  'drop', // drop(options, callback)\n  'dropIndex', // dropIndex(indexName, options, callback)\n  'dropIndexes', // dropIndexes(options, callback)\n  'estimatedDocumentCount', // estimatedDocumentCount(options, callback)\n  'find', // find(query, options, callback)\n  'findOne', // findOne(query, options, callback)\n  'findOneAndDelete', // findOneAndDelete(filter, options, callback)\n  'findOneAndReplace', // findOneAndReplace(filter, replacement, options, callback)\n  'findOneAndUpdate', // findOneAndUpdate(filter, update, options, callback)\n  'indexes', // indexes(options, callback)\n  'indexExists', // indexExists(indexes, options, callback)\n  'indexInformation', // indexInformation(options, callback)\n  'initializeOrderedBulkOp', // initializeOrderedBulkOp(options, callback)\n  'insertMany', // insertMany(docs, options, callback)\n  'insertOne', // insertOne(doc, options, callback)\n  'isCapped', // isCapped(options, callback)\n  'mapReduce', // mapReduce(map, reduce, options, callback)\n  'options', // options(options, callback)\n  'parallelCollectionScan', // parallelCollectionScan(options, callback)\n  'rename', // rename(newName, options, callback)\n  'replaceOne', // replaceOne(filter, doc, options, callback)\n  'stats', // stats(options, callback)\n  'updateMany', // updateMany(filter, update, options, callback)\n  'updateOne', // updateOne(filter, update, options, callback)\n] as const;\n\n// All of the operations above take `options` and `callback` as their final parameters, but some of them\n// take additional parameters as well. For those operations, this is a map of\n// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's\n// positional arguments when we add them to the span's `data` object later\nconst OPERATION_SIGNATURES: {\n  [op in Operation]?: string[];\n} = {\n  // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well\n  // see https://github.com/getsentry/sentry-javascript/pull/3102\n  bulkWrite: ['operations'],\n  countDocuments: ['query'],\n  createIndex: ['fieldOrSpec'],\n  createIndexes: ['indexSpecs'],\n  deleteMany: ['filter'],\n  deleteOne: ['filter'],\n  distinct: ['key', 'query'],\n  dropIndex: ['indexName'],\n  find: ['query'],\n  findOne: ['query'],\n  findOneAndDelete: ['filter'],\n  findOneAndReplace: ['filter', 'replacement'],\n  findOneAndUpdate: ['filter', 'update'],\n  indexExists: ['indexes'],\n  insertMany: ['docs'],\n  insertOne: ['doc'],\n  mapReduce: ['map', 'reduce'],\n  rename: ['newName'],\n  replaceOne: ['filter', 'doc'],\n  updateMany: ['filter', 'update'],\n  updateOne: ['filter', 'update'],\n};\n\ninterface MongoCollection {\n  collectionName: string;\n  dbName: string;\n  namespace: string;\n  prototype: {\n    [operation in Operation]: (...args: unknown[]) => unknown;\n  };\n}\n\ninterface MongoOptions {\n  operations?: Operation[];\n  describeOperations?: boolean | Operation[];\n  useMongoose?: boolean;\n}\n\n/** Tracing integration for mongo package */\nexport class Mongo implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Mongo';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Mongo.id;\n\n  private _operations: Operation[];\n  private _describeOperations?: boolean | Operation[];\n  private _useMongoose: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: MongoOptions = {}) {\n    this._operations = Array.isArray(options.operations) ? options.operations : (OPERATIONS as unknown as Operation[]);\n    this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;\n    this._useMongoose = !!options.useMongoose;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    const moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n    const pkg = loadModule<{ Collection: MongoCollection }>(moduleName);\n\n    if (!pkg) {\n      IS_DEBUG_BUILD && logger.error(`Mongo Integration was unable to require \\`${moduleName}\\` package.`);\n      return;\n    }\n\n    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);\n  }\n\n  /**\n   * Patches original collection methods\n   */\n  private _instrumentOperations(collection: MongoCollection, operations: Operation[], getCurrentHub: () => Hub): void {\n    operations.forEach((operation: Operation) => this._patchOperation(collection, operation, getCurrentHub));\n  }\n\n  /**\n   * Patches original collection to utilize our tracing functionality\n   */\n  private _patchOperation(collection: MongoCollection, operation: Operation, getCurrentHub: () => Hub): void {\n    if (!(operation in collection.prototype)) return;\n\n    const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);\n\n    fill(collection.prototype, operation, function (orig: () => void | Promise<unknown>) {\n      return function (this: unknown, ...args: unknown[]) {\n        const lastArg = args[args.length - 1];\n        const scope = getCurrentHub().getScope();\n        const parentSpan = scope?.getSpan();\n\n        // Check if the operation was passed a callback. (mapReduce requires a different check, as\n        // its (non-callback) arguments can also be functions.)\n        if (typeof lastArg !== 'function' || (operation === 'mapReduce' && args.length === 2)) {\n          const span = parentSpan?.startChild(getSpanContext(this, operation, args));\n          const maybePromise = orig.call(this, ...args) as Promise<unknown>;\n\n          if (isThenable(maybePromise)) {\n            return maybePromise.then((res: unknown) => {\n              span?.finish();\n              return res;\n            });\n          } else {\n            span?.finish();\n            return maybePromise;\n          }\n        }\n\n        const span = parentSpan?.startChild(getSpanContext(this, operation, args.slice(0, -1)));\n        return orig.call(this, ...args.slice(0, -1), function (err: Error, result: unknown) {\n          span?.finish();\n          lastArg(err, result);\n        });\n      };\n    });\n  }\n\n  /**\n   * Form a SpanContext based on the user input to a given operation.\n   */\n  private _getSpanContextFromOperationArguments(\n    collection: MongoCollection,\n    operation: Operation,\n    args: unknown[],\n  ): SpanContext {\n    const data: { [key: string]: string } = {\n      collectionName: collection.collectionName,\n      dbName: collection.dbName,\n      namespace: collection.namespace,\n    };\n    const spanContext: SpanContext = {\n      op: 'db',\n      description: operation,\n      data,\n    };\n\n    // If the operation takes no arguments besides `options` and `callback`, or if argument\n    // collection is disabled for this operation, just return early.\n    const signature = OPERATION_SIGNATURES[operation];\n    const shouldDescribe = Array.isArray(this._describeOperations)\n      ? this._describeOperations.includes(operation)\n      : this._describeOperations;\n\n    if (!signature || !shouldDescribe) {\n      return spanContext;\n    }\n\n    try {\n      // Special case for `mapReduce`, as the only one accepting functions as arguments.\n      if (operation === 'mapReduce') {\n        const [map, reduce] = args as { name?: string }[];\n        data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';\n        data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';\n      } else {\n        for (let i = 0; i < signature.length; i++) {\n          data[signature[i]] = JSON.stringify(args[i]);\n        }\n      }\n    } catch (_oO) {\n      // no-empty\n    }\n\n    return spanContext;\n  }\n}\n", "import { getGlobalObject, logger } from '@sentry/utils';\n\nimport { FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS } from '../constants';\nimport { IS_DEBUG_BUILD } from '../flags';\nimport { IdleTransaction } from '../idletransaction';\nimport { SpanStatusType } from '../span';\nimport { getActiveTransaction } from '../utils';\n\nconst global = getGlobalObject<Window>();\n\n/**\n * Add a listener that cancels and finishes a transaction when the global\n * document is hidden.\n */\nexport function registerBackgroundTabDetection(): void {\n  if (global && global.document) {\n    global.document.addEventListener('visibilitychange', () => {\n      const activeTransaction = getActiveTransaction() as IdleTransaction;\n      if (global.document.hidden && activeTransaction) {\n        const statusType: SpanStatusType = 'cancelled';\n\n        IS_DEBUG_BUILD &&\n          logger.log(\n            `[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${activeTransaction.op}`,\n          );\n        // We should not set status if it is already set, this prevent important statuses like\n        // error or data loss from being overwritten on transaction.\n        if (!activeTransaction.status) {\n          activeTransaction.setStatus(statusType);\n        }\n        activeTransaction.setTag('visibilitychange', 'document.hidden');\n        activeTransaction.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[2]);\n        activeTransaction.finish();\n      }\n    });\n  } else {\n    IS_DEBUG_BUILD && logger.warn('[Tracing] Could not set up background tab detection due to lack of global document');\n  }\n}\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Metric, ReportHandler } from '../types';\n\nexport const bindReporter = (\n  callback: ReportHandler,\n  metric: Metric,\n  reportAllChanges?: boolean,\n): ((forceReport?: boolean) => void) => {\n  let prevValue: number;\n  return (forceReport?: boolean) => {\n    if (metric.value >= 0) {\n      if (forceReport || reportAllChanges) {\n        metric.delta = metric.value - (prevValue || 0);\n\n        // Report the metric if there's a non-zero delta or if no previous\n        // value exists (which can happen in the case of the document becoming\n        // hidden when the metric value is 0).\n        // See: https://github.com/GoogleChrome/web-vitals/issues/14\n        if (metric.delta || prevValue === undefined) {\n          prevValue = metric.value;\n          callback(metric);\n        }\n      }\n    }\n  };\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Performantly generate a unique, 30-char string by combining a version\n * number, the current timestamp with a 13-digit number integer.\n * @return {string}\n */\nexport const generateUniqueID = (): string => {\n  return `v2-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Metric } from '../types';\nimport { generateUniqueID } from './generateUniqueID';\n\nexport const initMetric = (name: Metric['name'], value?: number): Metric => {\n  return {\n    name,\n    value: value ?? -1,\n    delta: 0,\n    entries: [],\n    id: generateUniqueID(),\n  };\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface PerformanceEntryHandler {\n  (entry: PerformanceEntry): void;\n}\n\n/**\n * Takes a performance entry type and a callback function, and creates a\n * `PerformanceObserver` instance that will observe the specified entry type\n * with buffering enabled and call the callback _for each entry_.\n *\n * This function also feature-detects entry support and wraps the logic in a\n * try/catch to avoid errors in unsupporting browsers.\n */\nexport const observe = (type: string, callback: PerformanceEntryHandler): PerformanceObserver | undefined => {\n  try {\n    if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n      // More extensive feature detect needed for Firefox due to:\n      // https://github.com/GoogleChrome/web-vitals/issues/142\n      if (type === 'first-input' && !('PerformanceEventTiming' in self)) {\n        return;\n      }\n\n      const po: PerformanceObserver = new PerformanceObserver(l => l.getEntries().map(callback));\n\n      po.observe({ type, buffered: true });\n      return po;\n    }\n  } catch (e) {\n    // Do nothing.\n  }\n  return;\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobalObject } from '@sentry/utils';\n\nexport interface OnHiddenCallback {\n  (event: Event): void;\n}\n\nexport const onHidden = (cb: OnHiddenCallback, once?: boolean): void => {\n  const onHiddenOrPageHide = (event: Event): void => {\n    if (event.type === 'pagehide' || getGlobalObject<Window>().document.visibilityState === 'hidden') {\n      cb(event);\n      if (once) {\n        removeEventListener('visibilitychange', onHiddenOrPageHide, true);\n        removeEventListener('pagehide', onHiddenOrPageHide, true);\n      }\n    }\n  };\n  addEventListener('visibilitychange', onHiddenOrPageHide, true);\n  // Some browsers have buggy implementations of visibilitychange,\n  // so we use pagehide in addition, just to be safe.\n  addEventListener('pagehide', onHiddenOrPageHide, true);\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bindReporter } from './lib/bindReporter';\nimport { initMetric } from './lib/initMetric';\nimport { observe, PerformanceEntryHandler } from './lib/observe';\nimport { onHidden } from './lib/onHidden';\nimport { ReportHandler } from './types';\n\n// https://wicg.github.io/layout-instability/#sec-layout-shift\nexport interface LayoutShift extends PerformanceEntry {\n  value: number;\n  hadRecentInput: boolean;\n  sources: Array<LayoutShiftAttribution>;\n  toJSON(): Record<string, unknown>;\n}\n\nexport interface LayoutShiftAttribution {\n  node?: Node;\n  previousRect: DOMRectReadOnly;\n  currentRect: DOMRectReadOnly;\n}\n\nexport const getCLS = (onReport: ReportHandler, reportAllChanges?: boolean): void => {\n  const metric = initMetric('CLS', 0);\n  let report: ReturnType<typeof bindReporter>;\n\n  let sessionValue = 0;\n  let sessionEntries: PerformanceEntry[] = [];\n\n  const entryHandler = (entry: LayoutShift): void => {\n    // Only count layout shifts without recent user input.\n    // TODO: Figure out why entry can be undefined\n    if (entry && !entry.hadRecentInput) {\n      const firstSessionEntry = sessionEntries[0];\n      const lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n\n      // If the entry occurred less than 1 second after the previous entry and\n      // less than 5 seconds after the first entry in the session, include the\n      // entry in the current session. Otherwise, start a new session.\n      if (\n        sessionValue &&\n        sessionEntries.length !== 0 &&\n        entry.startTime - lastSessionEntry.startTime < 1000 &&\n        entry.startTime - firstSessionEntry.startTime < 5000\n      ) {\n        sessionValue += entry.value;\n        sessionEntries.push(entry);\n      } else {\n        sessionValue = entry.value;\n        sessionEntries = [entry];\n      }\n\n      // If the current session value is larger than the current CLS value,\n      // update CLS and the entries contributing to it.\n      if (sessionValue > metric.value) {\n        metric.value = sessionValue;\n        metric.entries = sessionEntries;\n        if (report) {\n          report();\n        }\n      }\n    }\n  };\n\n  const po = observe('layout-shift', entryHandler as PerformanceEntryHandler);\n  if (po) {\n    report = bindReporter(onReport, metric, reportAllChanges);\n\n    onHidden(() => {\n      po.takeRecords().map(entryHandler as PerformanceEntryHandler);\n      report(true);\n    });\n  }\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobalObject } from '@sentry/utils';\n\nimport { onHidden } from './onHidden';\n\nlet firstHiddenTime = -1;\n\nconst initHiddenTime = (): number => {\n  return getGlobalObject<Window>().document.visibilityState === 'hidden' ? 0 : Infinity;\n};\n\nconst trackChanges = (): void => {\n  // Update the time if/when the document becomes hidden.\n  onHidden(({ timeStamp }) => {\n    firstHiddenTime = timeStamp;\n  }, true);\n};\n\nexport const getVisibilityWatcher = (): {\n  readonly firstHiddenTime: number;\n} => {\n  if (firstHiddenTime < 0) {\n    // If the document is hidden when this code runs, assume it was hidden\n    // since navigation start. This isn't a perfect heuristic, but it's the\n    // best we can do until an API is available to support querying past\n    // visibilityState.\n    firstHiddenTime = initHiddenTime();\n    trackChanges();\n  }\n  return {\n    get firstHiddenTime() {\n      return firstHiddenTime;\n    },\n  };\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bindReporter } from './lib/bindReporter';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher';\nimport { initMetric } from './lib/initMetric';\nimport { observe, PerformanceEntryHandler } from './lib/observe';\nimport { onHidden } from './lib/onHidden';\nimport { PerformanceEventTiming, ReportHandler } from './types';\n\nexport const getFID = (onReport: ReportHandler, reportAllChanges?: boolean): void => {\n  const visibilityWatcher = getVisibilityWatcher();\n  const metric = initMetric('FID');\n  let report: ReturnType<typeof bindReporter>;\n\n  const entryHandler = (entry: PerformanceEventTiming): void => {\n    // Only report if the page wasn't hidden prior to the first input.\n    if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {\n      metric.value = entry.processingStart - entry.startTime;\n      metric.entries.push(entry);\n      report(true);\n    }\n  };\n\n  const po = observe('first-input', entryHandler as PerformanceEntryHandler);\n  if (po) {\n    report = bindReporter(onReport, metric, reportAllChanges);\n    onHidden(() => {\n      po.takeRecords().map(entryHandler as PerformanceEntryHandler);\n      po.disconnect();\n    }, true);\n  }\n};\n", "/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { bindReporter } from './lib/bindReporter';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher';\nimport { initMetric } from './lib/initMetric';\nimport { observe, PerformanceEntryHandler } from './lib/observe';\nimport { onHidden } from './lib/onHidden';\nimport { ReportHandler } from './types';\n\n// https://wicg.github.io/largest-contentful-paint/#sec-largest-contentful-paint-interface\nexport interface LargestContentfulPaint extends PerformanceEntry {\n  renderTime: DOMHighResTimeStamp;\n  loadTime: DOMHighResTimeStamp;\n  size: number;\n  id: string;\n  url: string;\n  element?: Element;\n  toJSON(): Record<string, string>;\n}\n\nconst reportedMetricIDs: Record<string, boolean> = {};\n\nexport const getLCP = (onReport: ReportHandler, reportAllChanges?: boolean): void => {\n  const visibilityWatcher = getVisibilityWatcher();\n  const metric = initMetric('LCP');\n  let report: ReturnType<typeof bindReporter>;\n\n  const entryHandler = (entry: PerformanceEntry): void => {\n    // The startTime attribute returns the value of the renderTime if it is not 0,\n    // and the value of the loadTime otherwise.\n    const value = entry.startTime;\n\n    // If the page was hidden prior to paint time of the entry,\n    // ignore it and mark the metric as final, otherwise add the entry.\n    if (value < visibilityWatcher.firstHiddenTime) {\n      metric.value = value;\n      metric.entries.push(entry);\n    }\n\n    if (report) {\n      report();\n    }\n  };\n\n  const po = observe('largest-contentful-paint', entryHandler);\n\n  if (po) {\n    report = bindReporter(onReport, metric, reportAllChanges);\n\n    const stopListening = (): void => {\n      if (!reportedMetricIDs[metric.id]) {\n        po.takeRecords().map(entryHandler as PerformanceEntryHandler);\n        po.disconnect();\n        reportedMetricIDs[metric.id] = true;\n        report(true);\n      }\n    };\n\n    // Stop listening after input. Note: while scrolling is an input that\n    // stop LCP observation, it's unreliable since it can be programmatically\n    // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75\n    ['keydown', 'click'].forEach(type => {\n      addEventListener(type, stopListening, { once: true, capture: true });\n    });\n\n    onHidden(stopListening, true);\n  }\n};\n", "/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Measurements, SpanContext } from '@sentry/types';\nimport { browserPerformanceTimeOrigin, getGlobalObject, htmlTreeAsString, isNodeEnv, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../flags';\nimport { Span } from '../span';\nimport { Transaction } from '../transaction';\nimport { msToSec } from '../utils';\nimport { getCLS, LayoutShift } from './web-vitals/getCLS';\nimport { getFID } from './web-vitals/getFID';\nimport { getLCP, LargestContentfulPaint } from './web-vitals/getLCP';\nimport { getVisibilityWatcher } from './web-vitals/lib/getVisibilityWatcher';\nimport { NavigatorDeviceMemory, NavigatorNetworkInformation } from './web-vitals/types';\n\nconst global = getGlobalObject<Window>();\n\n/** Class tracking metrics  */\nexport class MetricsInstrumentation {\n  private _measurements: Measurements = {};\n\n  private _performanceCursor: number = 0;\n  private _lcpEntry: LargestContentfulPaint | undefined;\n  private _clsEntry: LayoutShift | undefined;\n\n  public constructor(private _reportAllChanges: boolean = false) {\n    if (!isNodeEnv() && global && global.performance && global.document) {\n      if (global.performance.mark) {\n        global.performance.mark('sentry-tracing-init');\n      }\n\n      this._trackCLS();\n      this._trackLCP();\n      this._trackFID();\n    }\n  }\n\n  /** Add performance related spans to a transaction */\n  public addPerformanceEntries(transaction: Transaction): void {\n    if (!global || !global.performance || !global.performance.getEntries || !browserPerformanceTimeOrigin) {\n      // Gatekeeper if performance API not available\n      return;\n    }\n\n    IS_DEBUG_BUILD && logger.log('[Tracing] Adding & adjusting spans using Performance API');\n\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n\n    let responseStartTimestamp: number | undefined;\n    let requestStartTimestamp: number | undefined;\n\n    global.performance\n      .getEntries()\n      .slice(this._performanceCursor)\n      .forEach((entry: Record<string, any>) => {\n        const startTime = msToSec(entry.startTime as number);\n        const duration = msToSec(entry.duration as number);\n\n        if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n          return;\n        }\n\n        switch (entry.entryType) {\n          case 'navigation': {\n            addNavigationSpans(transaction, entry, timeOrigin);\n            responseStartTimestamp = timeOrigin + msToSec(entry.responseStart as number);\n            requestStartTimestamp = timeOrigin + msToSec(entry.requestStart as number);\n            break;\n          }\n          case 'mark':\n          case 'paint':\n          case 'measure': {\n            const startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n            // capture web vitals\n\n            const firstHidden = getVisibilityWatcher();\n            // Only report if the page wasn't hidden prior to the web vital.\n            const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n            if (entry.name === 'first-paint' && shouldRecord) {\n              IS_DEBUG_BUILD && logger.log('[Measurements] Adding FP');\n              this._measurements['fp'] = { value: entry.startTime };\n              this._measurements['mark.fp'] = { value: startTimestamp };\n            }\n\n            if (entry.name === 'first-contentful-paint' && shouldRecord) {\n              IS_DEBUG_BUILD && logger.log('[Measurements] Adding FCP');\n              this._measurements['fcp'] = { value: entry.startTime };\n              this._measurements['mark.fcp'] = { value: startTimestamp };\n            }\n\n            break;\n          }\n          case 'resource': {\n            const resourceName = (entry.name as string).replace(global.location.origin, '');\n            addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n            break;\n          }\n          default:\n          // Ignore other entry types.\n        }\n      });\n\n    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n\n    this._trackNavigator(transaction);\n\n    // Measurements are only available for pageload transactions\n    if (transaction.op === 'pageload') {\n      // normalize applicable web vital values to be relative to transaction.startTimestamp\n\n      const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n\n      // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the\n      // start of the response in milliseconds\n      if (typeof responseStartTimestamp === 'number') {\n        IS_DEBUG_BUILD && logger.log('[Measurements] Adding TTFB');\n        this._measurements['ttfb'] = { value: (responseStartTimestamp - transaction.startTimestamp) * 1000 };\n\n        if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {\n          // Capture the time spent making the request and receiving the first byte of the response.\n          // This is the time between the start of the request and the start of the response in milliseconds.\n          this._measurements['ttfb.requestTime'] = { value: (responseStartTimestamp - requestStartTimestamp) * 1000 };\n        }\n      }\n\n      ['fcp', 'fp', 'lcp'].forEach(name => {\n        if (!this._measurements[name] || timeOrigin >= transaction.startTimestamp) {\n          return;\n        }\n\n        // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n        // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n        // to be adjusted to be relative to transaction.startTimestamp.\n\n        const oldValue = this._measurements[name].value;\n        const measurementTimestamp = timeOrigin + msToSec(oldValue);\n        // normalizedValue should be in milliseconds\n        const normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n\n        const delta = normalizedValue - oldValue;\n        IS_DEBUG_BUILD &&\n          logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);\n\n        this._measurements[name].value = normalizedValue;\n      });\n\n      if (this._measurements['mark.fid'] && this._measurements['fid']) {\n        // create span for FID\n\n        _startChild(transaction, {\n          description: 'first input delay',\n          endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),\n          op: 'web.vitals',\n          startTimestamp: this._measurements['mark.fid'].value,\n        });\n      }\n\n      // If FCP is not recorded we should not record the cls value\n      // according to the new definition of CLS.\n      if (!('fcp' in this._measurements)) {\n        delete this._measurements.cls;\n      }\n\n      transaction.setMeasurements(this._measurements);\n      tagMetricInfo(transaction, this._lcpEntry, this._clsEntry);\n      transaction.setTag('sentry_reportAllChanges', this._reportAllChanges);\n    }\n  }\n\n  /**\n   * Capture the information of the user agent.\n   */\n  private _trackNavigator(transaction: Transaction): void {\n    const navigator = global.navigator as null | (Navigator & NavigatorNetworkInformation & NavigatorDeviceMemory);\n    if (!navigator) {\n      return;\n    }\n\n    // track network connectivity\n    const connection = navigator.connection;\n    if (connection) {\n      if (connection.effectiveType) {\n        transaction.setTag('effectiveConnectionType', connection.effectiveType);\n      }\n\n      if (connection.type) {\n        transaction.setTag('connectionType', connection.type);\n      }\n\n      if (isMeasurementValue(connection.rtt)) {\n        this._measurements['connection.rtt'] = { value: connection.rtt as number };\n      }\n\n      if (isMeasurementValue(connection.downlink)) {\n        this._measurements['connection.downlink'] = { value: connection.downlink as number };\n      }\n    }\n\n    if (isMeasurementValue(navigator.deviceMemory)) {\n      transaction.setTag('deviceMemory', String(navigator.deviceMemory));\n    }\n\n    if (isMeasurementValue(navigator.hardwareConcurrency)) {\n      transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n    }\n  }\n\n  /** Starts tracking the Cumulative Layout Shift on the current page. */\n  private _trackCLS(): void {\n    // See:\n    // https://web.dev/evolving-cls/\n    // https://web.dev/cls-web-tooling/\n    getCLS(metric => {\n      const entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n\n      IS_DEBUG_BUILD && logger.log('[Measurements] Adding CLS');\n      this._measurements['cls'] = { value: metric.value };\n      this._clsEntry = entry as LayoutShift;\n    });\n  }\n\n  /** Starts tracking the Largest Contentful Paint on the current page. */\n  private _trackLCP(): void {\n    getLCP(metric => {\n      const entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n\n      const timeOrigin = msToSec(browserPerformanceTimeOrigin as number);\n      const startTime = msToSec(entry.startTime);\n      IS_DEBUG_BUILD && logger.log('[Measurements] Adding LCP');\n      this._measurements['lcp'] = { value: metric.value };\n      this._measurements['mark.lcp'] = { value: timeOrigin + startTime };\n      this._lcpEntry = entry as LargestContentfulPaint;\n    }, this._reportAllChanges);\n  }\n\n  /** Starts tracking the First Input Delay on the current page. */\n  private _trackFID(): void {\n    getFID(metric => {\n      const entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n\n      const timeOrigin = msToSec(browserPerformanceTimeOrigin as number);\n      const startTime = msToSec(entry.startTime);\n      IS_DEBUG_BUILD && logger.log('[Measurements] Adding FID');\n      this._measurements['fid'] = { value: metric.value };\n      this._measurements['mark.fid'] = { value: timeOrigin + startTime };\n    });\n  }\n}\n\n/** Instrument navigation entries */\nfunction addNavigationSpans(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(event => {\n    addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);\n  });\n  addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'TLS/SSL', 'connectEnd');\n  addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'cache', 'domainLookupStart');\n  addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin, 'DNS');\n  addRequest(transaction, entry, timeOrigin);\n}\n\n/** Create measure related spans */\nfunction addMeasureSpans(\n  transaction: Transaction,\n  entry: Record<string, any>,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): number {\n  const measureStartTimestamp = timeOrigin + startTime;\n  const measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name as string,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType as string,\n    startTimestamp: measureStartTimestamp,\n  });\n\n  return measureStartTimestamp;\n}\n\nexport interface ResourceEntry extends Record<string, unknown> {\n  initiatorType?: string;\n  transferSize?: number;\n  encodedBodySize?: number;\n  decodedBodySize?: number;\n}\n\n/** Create resource-related spans */\nexport function addResourceSpans(\n  transaction: Transaction,\n  entry: ResourceEntry,\n  resourceName: string,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): void {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n\n  const data: Record<string, any> = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp,\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource',\n    startTimestamp,\n    data,\n  });\n}\n\n/** Create performance navigation related spans */\nfunction addPerformanceNavigationTiming(\n  transaction: Transaction,\n  entry: Record<string, any>,\n  event: string,\n  timeOrigin: number,\n  description?: string,\n  eventEnd?: string,\n): void {\n  const end = eventEnd ? (entry[eventEnd] as number | undefined) : (entry[`${event}End`] as number | undefined);\n  const start = entry[`${event}Start`] as number | undefined;\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    op: 'browser',\n    description: description ?? event,\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end),\n  });\n}\n\n/** Create request and response related spans */\nfunction addRequest(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart as number),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n  });\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart as number),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n  });\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nexport function _startChild(transaction: Transaction, { startTimestamp, ...ctx }: SpanContext): Span {\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild({\n    startTimestamp,\n    ...ctx,\n  });\n}\n\n/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value: any): boolean {\n  return typeof value === 'number' && isFinite(value);\n}\n\n/** Add LCP / CLS data to transaction to allow debugging */\nfunction tagMetricInfo(\n  transaction: Transaction,\n  lcpEntry: MetricsInstrumentation['_lcpEntry'],\n  clsEntry: MetricsInstrumentation['_clsEntry'],\n): void {\n  if (lcpEntry) {\n    IS_DEBUG_BUILD && logger.log('[Measurements] Adding LCP Data');\n\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (lcpEntry.element) {\n      transaction.setTag('lcp.element', htmlTreeAsString(lcpEntry.element));\n    }\n\n    if (lcpEntry.id) {\n      transaction.setTag('lcp.id', lcpEntry.id);\n    }\n\n    if (lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      transaction.setTag('lcp.url', lcpEntry.url.trim().slice(0, 200));\n    }\n\n    transaction.setTag('lcp.size', lcpEntry.size);\n  }\n\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n  if (clsEntry && clsEntry.sources) {\n    IS_DEBUG_BUILD && logger.log('[Measurements] Adding CLS Data');\n    clsEntry.sources.forEach((source, index) =>\n      transaction.setTag(`cls.source.${index + 1}`, htmlTreeAsString(source.node)),\n    );\n  }\n}\n", "import { addInstrumentationHandler, isInstanceOf, isMatchingPattern } from '@sentry/utils';\n\nimport { Span } from '../span';\nimport { getActiveTransaction, hasTracingEnabled } from '../utils';\n\nexport const DEFAULT_TRACING_ORIGINS = ['localhost', /^\\//];\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * List of strings / regex where the integration should create Spans out of. Additionally this will be used\n   * to define which outgoing requests the `sentry-trace` header will be attached to.\n   *\n   * Default: ['localhost', /^\\//] {@see DEFAULT_TRACING_ORIGINS}\n   */\n  tracingOrigins: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * By default it uses the `tracingOrigins` options as a url match.\n   */\n  shouldCreateSpanForRequest?(url: string): boolean;\n}\n\n/** Data returned from fetch callback */\nexport interface FetchData {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: any[]; // the arguments passed to the fetch call itself\n  fetchData?: {\n    method: string;\n    url: string;\n    // span_id\n    __span?: string;\n  };\n\n  // TODO Should this be unknown instead? If we vendor types, make it a Response\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  response?: any;\n  error?: unknown;\n\n  startTimestamp: number;\n  endTimestamp?: number;\n}\n\n/** Data returned from XHR request */\nexport interface XHRData {\n  xhr?: {\n    __sentry_xhr__?: {\n      method: string;\n      url: string;\n      status_code: number;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      data: Record<string, any>;\n    };\n    __sentry_xhr_span_id__?: string;\n    setRequestHeader?: (key: string, val: string) => void;\n    __sentry_own_request__?: boolean;\n  };\n  startTimestamp: number;\n  endTimestamp?: number;\n}\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  tracingOrigins: DEFAULT_TRACING_ORIGINS,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(_options?: Partial<RequestInstrumentationOptions>): void {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  const { traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest } = {\n    ...defaultRequestInstrumentationOptions,\n    ..._options,\n  };\n\n  // We should cache url -> decision so that we don't have to compute\n  // regexp everytime we create a request.\n  const urlMap: Record<string, boolean> = {};\n\n  const defaultShouldCreateSpan = (url: string): boolean => {\n    if (urlMap[url]) {\n      return urlMap[url];\n    }\n    const origins = tracingOrigins;\n    urlMap[url] =\n      origins.some((origin: string | RegExp) => isMatchingPattern(url, origin)) &&\n      !isMatchingPattern(url, 'sentry_key');\n    return urlMap[url];\n  };\n\n  // We want that our users don't have to re-implement shouldCreateSpanForRequest themselves\n  // That's why we filter out already unwanted Spans from tracingOrigins\n  let shouldCreateSpan = defaultShouldCreateSpan;\n  if (typeof shouldCreateSpanForRequest === 'function') {\n    shouldCreateSpan = (url: string) => {\n      return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);\n    };\n  }\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    addInstrumentationHandler('fetch', (handlerData: FetchData) => {\n      fetchCallback(handlerData, shouldCreateSpan, spans);\n    });\n  }\n\n  if (traceXHR) {\n    addInstrumentationHandler('xhr', (handlerData: XHRData) => {\n      xhrCallback(handlerData, shouldCreateSpan, spans);\n    });\n  }\n}\n\n/**\n * Create and track fetch request spans\n */\nexport function fetchCallback(\n  handlerData: FetchData,\n  shouldCreateSpan: (url: string) => boolean,\n  spans: Record<string, Span>,\n): void {\n  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {\n    return;\n  }\n\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      if (handlerData.response) {\n        // TODO (kmclb) remove this once types PR goes through\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        span.setHttpStatus(handlerData.response.status);\n      } else if (handlerData.error) {\n        span.setStatus('internal_error');\n      }\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const span = activeTransaction.startChild({\n      data: {\n        ...handlerData.fetchData,\n        type: 'fetch',\n      },\n      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.fetchData.__span = span.spanId;\n    spans[span.spanId] = span;\n\n    const request = (handlerData.args[0] = handlerData.args[0] as string | Request);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const options = (handlerData.args[1] = (handlerData.args[1] as { [key: string]: any }) || {});\n    let headers = options.headers;\n    if (isInstanceOf(request, Request)) {\n      headers = (request as Request).headers;\n    }\n    if (headers) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (typeof headers.append === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        headers.append('sentry-trace', span.toTraceparent());\n      } else if (Array.isArray(headers)) {\n        headers = [...headers, ['sentry-trace', span.toTraceparent()]];\n      } else {\n        headers = { ...headers, 'sentry-trace': span.toTraceparent() };\n      }\n    } else {\n      headers = { 'sentry-trace': span.toTraceparent() };\n    }\n    options.headers = headers;\n  }\n}\n\n/**\n * Create and track xhr request spans\n */\nexport function xhrCallback(\n  handlerData: XHRData,\n  shouldCreateSpan: (url: string) => boolean,\n  spans: Record<string, Span>,\n): void {\n  if (\n    !hasTracingEnabled() ||\n    (handlerData.xhr && handlerData.xhr.__sentry_own_request__) ||\n    !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))\n  ) {\n    return;\n  }\n\n  const xhr = handlerData.xhr.__sentry_xhr__;\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      span.setHttpStatus(xhr.status_code);\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n\n  // if not, create a new span to track it\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const span = activeTransaction.startChild({\n      data: {\n        ...xhr.data,\n        type: 'xhr',\n        method: xhr.method,\n        url: xhr.url,\n      },\n      description: `${xhr.method} ${xhr.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;\n    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;\n\n    if (handlerData.xhr.setRequestHeader) {\n      try {\n        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n  }\n}\n", "import { Transaction, TransactionContext } from '@sentry/types';\nimport { addInstrumentationHandler, getGlobalObject, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../flags';\n\nconst global = getGlobalObject<Window>();\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nexport function instrumentRoutingWithDefaults<T extends Transaction>(\n  customStartTransaction: (context: TransactionContext) => T | undefined,\n  startTransactionOnPageLoad: boolean = true,\n  startTransactionOnLocationChange: boolean = true,\n): void {\n  if (!global || !global.location) {\n    IS_DEBUG_BUILD && logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n\n  let startingUrl: string | undefined = global.location.href;\n\n  let activeTransaction: T | undefined;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = customStartTransaction({ name: global.location.pathname, op: 'pageload' });\n  }\n\n  if (startTransactionOnLocationChange) {\n    addInstrumentationHandler('history', ({ to, from }: { to: string; from?: string }) => {\n      /**\n       * This early return is there to account for some cases where a navigation transaction starts right after\n       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n       * create an uneccessary navigation transaction.\n       *\n       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n       * only be caused in certain development environments where the usage of a hot module reloader is causing\n       * errors.\n       */\n      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n        startingUrl = undefined;\n        return;\n      }\n\n      if (from !== to) {\n        startingUrl = undefined;\n        if (activeTransaction) {\n          IS_DEBUG_BUILD && logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n          // If there's an open transaction on the scope, we need to finish it before creating an new one.\n          activeTransaction.finish();\n        }\n        activeTransaction = customStartTransaction({ name: global.location.pathname, op: 'navigation' });\n      }\n    });\n  }\n}\n", "import { Hub } from '@sentry/hub';\nimport { EventProcessor, Integration, Transaction, TransactionContext } from '@sentry/types';\nimport { getGlobalObject, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../flags';\nimport { startIdleTransaction } from '../hubextensions';\nimport { DEFAULT_IDLE_TIMEOUT, IdleTransaction } from '../idletransaction';\nimport { extractTraceparentData, secToMs } from '../utils';\nimport { registerBackgroundTabDetection } from './backgroundtab';\nimport { MetricsInstrumentation } from './metrics';\nimport {\n  defaultRequestInstrumentationOptions,\n  instrumentOutgoingRequests,\n  RequestInstrumentationOptions,\n} from './request';\nimport { instrumentRoutingWithDefaults } from './router';\n\nexport const DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;\n\n/** Options for Browser Tracing integration */\nexport interface BrowserTracingOptions extends RequestInstrumentationOptions {\n  /**\n   * The time to wait in ms until the transaction will be finished. The transaction will use the end timestamp of\n   * the last finished span as the endtime for the transaction.\n   * Time is in ms.\n   *\n   * Default: 1000\n   */\n  idleTimeout: number;\n\n  /**\n   * Flag to enable/disable creation of `navigation` transaction on history changes.\n   *\n   * Default: true\n   */\n  startTransactionOnLocationChange: boolean;\n\n  /**\n   * Flag to enable/disable creation of `pageload` transaction on first pageload.\n   *\n   * Default: true\n   */\n  startTransactionOnPageLoad: boolean;\n\n  /**\n   * The maximum duration of a transaction before it will be marked as \"deadline_exceeded\".\n   * If you never want to mark a transaction set it to 0.\n   * Time is in seconds.\n   *\n   * Default: 600\n   */\n  maxTransactionDuration: number;\n\n  /**\n   * Flag Transactions where tabs moved to background with \"cancelled\". Browser background tab timing is\n   * not suited towards doing precise measurements of operations. By default, we recommend that this option\n   * be enabled as background transactions can mess up your statistics in nondeterministic ways.\n   *\n   * Default: true\n   */\n  markBackgroundTransactions: boolean;\n\n  /**\n   * _metricOptions allows the user to send options to change how metrics are collected.\n   *\n   * _metricOptions is currently experimental.\n   *\n   * Default: undefined\n   */\n  _metricOptions?: Partial<{ _reportAllChanges: boolean }>;\n\n  /**\n   * beforeNavigate is called before a pageload/navigation transaction is created and allows users to modify transaction\n   * context data, or drop the transaction entirely (by setting `sampled = false` in the context).\n   *\n   * Note: For legacy reasons, transactions can also be dropped by returning `undefined`.\n   *\n   * @param context: The context data which will be passed to `startTransaction` by default\n   *\n   * @returns A (potentially) modified context object, with `sampled = false` if the transaction should be dropped.\n   */\n  beforeNavigate?(context: TransactionContext): TransactionContext | undefined;\n\n  /**\n   * Instrumentation that creates routing change transactions. By default creates\n   * pageload and navigation transactions.\n   */\n  routingInstrumentation<T extends Transaction>(\n    customStartTransaction: (context: TransactionContext) => T | undefined,\n    startTransactionOnPageLoad?: boolean,\n    startTransactionOnLocationChange?: boolean,\n  ): void;\n}\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS = {\n  idleTimeout: DEFAULT_IDLE_TIMEOUT,\n  markBackgroundTransactions: true,\n  maxTransactionDuration: DEFAULT_MAX_TRANSACTION_DURATION_SECONDS,\n  routingInstrumentation: instrumentRoutingWithDefaults,\n  startTransactionOnLocationChange: true,\n  startTransactionOnPageLoad: true,\n  ...defaultRequestInstrumentationOptions,\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n */\nexport class BrowserTracing implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'BrowserTracing';\n\n  /** Browser Tracing integration options */\n  public options: BrowserTracingOptions;\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = BrowserTracing.id;\n\n  private _getCurrentHub?: () => Hub;\n\n  private readonly _metrics: MetricsInstrumentation;\n\n  private readonly _emitOptionsWarning?: boolean;\n\n  /** Store configured idle timeout so that it can be added as a tag to transactions */\n  private _configuredIdleTimeout: BrowserTracingOptions['idleTimeout'] | undefined = undefined;\n\n  public constructor(_options?: Partial<BrowserTracingOptions>) {\n    let tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins;\n    // NOTE: Logger doesn't work in constructors, as it's initialized after integrations instances\n    if (_options) {\n      this._configuredIdleTimeout = _options.idleTimeout;\n      if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins) && _options.tracingOrigins.length !== 0) {\n        tracingOrigins = _options.tracingOrigins;\n      } else {\n        IS_DEBUG_BUILD && (this._emitOptionsWarning = true);\n      }\n    }\n\n    this.options = {\n      ...DEFAULT_BROWSER_TRACING_OPTIONS,\n      ..._options,\n      tracingOrigins,\n    };\n\n    const { _metricOptions } = this.options;\n    this._metrics = new MetricsInstrumentation(_metricOptions && _metricOptions._reportAllChanges);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    this._getCurrentHub = getCurrentHub;\n\n    if (this._emitOptionsWarning) {\n      IS_DEBUG_BUILD &&\n        logger.warn(\n          '[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.',\n        );\n      IS_DEBUG_BUILD &&\n        logger.warn(\n          `[Tracing] We added a reasonable default for you: ${defaultRequestInstrumentationOptions.tracingOrigins}`,\n        );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const {\n      routingInstrumentation: instrumentRouting,\n      startTransactionOnLocationChange,\n      startTransactionOnPageLoad,\n      markBackgroundTransactions,\n      traceFetch,\n      traceXHR,\n      tracingOrigins,\n      shouldCreateSpanForRequest,\n    } = this.options;\n\n    instrumentRouting(\n      (context: TransactionContext) => this._createRouteTransaction(context),\n      startTransactionOnPageLoad,\n      startTransactionOnLocationChange,\n    );\n\n    if (markBackgroundTransactions) {\n      registerBackgroundTabDetection();\n    }\n\n    instrumentOutgoingRequests({ traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest });\n  }\n\n  /** Create routing idle transaction. */\n  private _createRouteTransaction(context: TransactionContext): Transaction | undefined {\n    if (!this._getCurrentHub) {\n      IS_DEBUG_BUILD &&\n        logger.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);\n      return undefined;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { beforeNavigate, idleTimeout, maxTransactionDuration } = this.options;\n\n    const parentContextFromHeader = context.op === 'pageload' ? getHeaderContext() : undefined;\n\n    const expandedContext = {\n      ...context,\n      ...parentContextFromHeader,\n      trimEnd: true,\n    };\n    const modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;\n\n    // For backwards compatibility reasons, beforeNavigate can return undefined to \"drop\" the transaction (prevent it\n    // from being sent to Sentry).\n    const finalContext = modifiedContext === undefined ? { ...expandedContext, sampled: false } : modifiedContext;\n\n    if (finalContext.sampled === false) {\n      IS_DEBUG_BUILD && logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n\n    IS_DEBUG_BUILD && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n\n    const hub = this._getCurrentHub();\n    const { location } = getGlobalObject() as WindowOrWorkerGlobalScope & { location: Location };\n\n    const idleTransaction = startIdleTransaction(\n      hub,\n      finalContext,\n      idleTimeout,\n      true,\n      { location }, // for use in the tracesSampler\n    );\n    idleTransaction.registerBeforeFinishCallback((transaction, endTimestamp) => {\n      this._metrics.addPerformanceEntries(transaction);\n      adjustTransactionDuration(secToMs(maxTransactionDuration), transaction, endTimestamp);\n    });\n\n    idleTransaction.setTag('idleTimeout', this._configuredIdleTimeout);\n\n    return idleTransaction as Transaction;\n  }\n}\n\n/**\n * Gets transaction context from a sentry-trace meta.\n *\n * @returns Transaction context data from the header or undefined if there's no header or the header is malformed\n */\nexport function getHeaderContext(): Partial<TransactionContext> | undefined {\n  const header = getMetaContent('sentry-trace');\n  if (header) {\n    return extractTraceparentData(header);\n  }\n\n  return undefined;\n}\n\n/** Returns the value of a meta tag */\nexport function getMetaContent(metaName: string): string | null {\n  const el = getGlobalObject<Window>().document.querySelector(`meta[name=${metaName}]`);\n  return el ? el.getAttribute('content') : null;\n}\n\n/** Adjusts transaction value based on max transaction duration */\nfunction adjustTransactionDuration(maxDuration: number, transaction: IdleTransaction, endTimestamp: number): void {\n  const diff = endTimestamp - transaction.startTimestamp;\n  const isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);\n  if (isOutdatedTransaction) {\n    transaction.setStatus('deadline_exceeded');\n    transaction.setTag('maxTransactionDurationExceeded', 'true');\n  }\n}\n", "/** The status of an Span.\n *\n * @deprecated Use string literals - if you require type casting, cast to SpanStatusType type\n */\n// eslint-disable-next-line import/export\nexport enum SpanStatus {\n  /** The operation completed successfully. */\n  Ok = 'ok',\n  /** Deadline expired before operation could complete. */\n  DeadlineExceeded = 'deadline_exceeded',\n  /** 401 Unauthorized (actually does mean unauthenticated according to RFC 7235) */\n  Unauthenticated = 'unauthenticated',\n  /** 403 Forbidden */\n  PermissionDenied = 'permission_denied',\n  /** 404 Not Found. Some requested entity (file or directory) was not found. */\n  NotFound = 'not_found',\n  /** 429 Too Many Requests */\n  ResourceExhausted = 'resource_exhausted',\n  /** Client specified an invalid argument. 4xx. */\n  InvalidArgument = 'invalid_argument',\n  /** 501 Not Implemented */\n  Unimplemented = 'unimplemented',\n  /** 503 Service Unavailable */\n  Unavailable = 'unavailable',\n  /** Other/generic 5xx. */\n  InternalError = 'internal_error',\n  /** Unknown. Any non-standard HTTP status code. */\n  UnknownError = 'unknown_error',\n  /** The operation was cancelled (typically by the user). */\n  Cancelled = 'cancelled',\n  /** Already exists (409) */\n  AlreadyExists = 'already_exists',\n  /** Operation was rejected because the system is not in a state required for the operation's */\n  FailedPrecondition = 'failed_precondition',\n  /** The operation was aborted, typically due to a concurrency issue. */\n  Aborted = 'aborted',\n  /** Operation was attempted past the valid range. */\n  OutOfRange = 'out_of_range',\n  /** Unrecoverable data loss or corruption */\n  DataLoss = 'data_loss',\n}\n", "import { addExtensionMethods } from './hubextensions';\nimport * as Integrations from './integrations';\n\nexport { Integrations };\n\n// This is already exported as part of `Integrations` above (and for the moment will remain so for\n// backwards compatibility), but that interferes with treeshaking, so we also export it separately\n// here.\n//\n// Previously we expected users to import tracing integrations like\n//\n// import { Integrations } from '@sentry/tracing';\n// const instance = new Integrations.BrowserTracing();\n//\n// This makes the integrations unable to be treeshaken though. To address this, we now have\n// this individual export. We now expect users to consume BrowserTracing like so:\n//\n// import { BrowserTracing } from '@sentry/tracing';\n// const instance = new BrowserTracing();\n//\n// For an example of of the new usage of BrowserTracing, see @sentry/nextjs index.client.ts\nexport { BrowserTracing } from './browser';\n\nexport { Span, SpanStatusType, spanStatusfromHttpCode } from './span';\n// eslint-disable-next-line deprecation/deprecation\nexport { SpanStatus } from './spanstatus';\nexport { Transaction } from './transaction';\nexport {\n  // TODO deprecate old name in v7\n  instrumentOutgoingRequests as registerRequestInstrumentation,\n  RequestInstrumentationOptions,\n  defaultRequestInstrumentationOptions,\n} from './browser';\nexport { IdleTransaction } from './idletransaction';\nexport { startIdleTransaction } from './hubextensions';\n\n// We are patching the global object with our hub extension methods\naddExtensionMethods();\n\nexport { addExtensionMethods };\n\nexport {\n  extractTraceparentData,\n  getActiveTransaction,\n  hasTracingEnabled,\n  stripUrlQueryAndFragment,\n  TRACEPARENT_REGEXP,\n} from './utils';\n"],
  "mappings": "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",
  "names": ["SpanRecorder", "Span", "Transaction", "IdleTransactionSpanRecorder", "IdleTransaction", "Express", "_a", "Postgres", "getCurrentHub", "_a", "Mysql", "getCurrentHub", "_a", "Mongo", "getCurrentHub", "_a", "global", "MetricsInstrumentation", "global", "BrowserTracing", "getCurrentHub", "SpanStatus"]
}

import {
  Hub,
  Scope,
  SentryError,
  Session,
  Severity,
  SyncPromise,
  __assign,
  __extends,
  __read,
  __spread,
  __values,
  addExceptionMechanism,
  addExceptionTypeValue,
  addGlobalEventProcessor,
  addInstrumentationHandler,
  addNonEnumerableProperty,
  checkOrSetAlreadyCaught,
  createClientReportEnvelope,
  createEnvelope,
  createStackParser,
  dateTimestampInSeconds,
  disabledUntil,
  dsnToString,
  eventStatusFromHttpCode,
  extractExceptionKeysForMessage,
  fill,
  forget,
  getCurrentHub,
  getEnvelopeType,
  getEventDescription,
  getFunctionName,
  getGlobalObject,
  getHubFromCarrier,
  getLocationHref,
  getOriginalFunction,
  htmlTreeAsString,
  isDOMError,
  isDOMException,
  isError,
  isErrorEvent,
  isEvent,
  isInstanceOf,
  isMatchingPattern,
  isNativeFetch,
  isPlainObject,
  isPrimitive,
  isRateLimited,
  isString,
  isThenable,
  logger,
  makeDsn,
  makeMain,
  makePromiseBuffer,
  markFunctionWrapped,
  normalize,
  normalizeToSize,
  parseUrl,
  rejectedSyncPromise,
  resolvedSyncPromise,
  safeJoin,
  serializeEnvelope,
  severityFromString,
  supportsFetch,
  supportsReferrerPolicy,
  truncate,
  updateRateLimits,
  urlEncode,
  uuid4
} from "./chunk-VGJ7RCHP.js";
import {
  __export
} from "./chunk-HUBM7RA2.js";

// node_modules/@sentry/minimal/esm/index.js
function callOnHub(method) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var hub = getCurrentHub();
  if (hub && hub[method]) {
    return hub[method].apply(hub, __spread(args));
  }
  throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
}
function captureException(exception, captureContext) {
  var syntheticException = new Error("Sentry syntheticException");
  return callOnHub("captureException", exception, {
    captureContext,
    originalException: exception,
    syntheticException
  });
}
function captureMessage(message, captureContext) {
  var syntheticException = new Error(message);
  var level = typeof captureContext === "string" ? captureContext : void 0;
  var context = typeof captureContext !== "string" ? { captureContext } : void 0;
  return callOnHub("captureMessage", message, level, __assign({ originalException: message, syntheticException }, context));
}
function captureEvent(event) {
  return callOnHub("captureEvent", event);
}
function configureScope(callback) {
  callOnHub("configureScope", callback);
}
function addBreadcrumb(breadcrumb) {
  callOnHub("addBreadcrumb", breadcrumb);
}
function setContext(name, context) {
  callOnHub("setContext", name, context);
}
function setExtras(extras) {
  callOnHub("setExtras", extras);
}
function setTags(tags) {
  callOnHub("setTags", tags);
}
function setExtra(key, extra) {
  callOnHub("setExtra", key, extra);
}
function setTag(key, value) {
  callOnHub("setTag", key, value);
}
function setUser(user) {
  callOnHub("setUser", user);
}
function withScope(callback) {
  callOnHub("withScope", callback);
}
function startTransaction(context, customSamplingContext) {
  return callOnHub("startTransaction", __assign({}, context), customSamplingContext);
}

// node_modules/@sentry/core/esm/api.js
var SENTRY_API_VERSION = "7";
var API = function() {
  function API2(dsn, metadata, tunnel) {
    if (metadata === void 0) {
      metadata = {};
    }
    this.dsn = dsn;
    this._dsnObject = makeDsn(dsn);
    this.metadata = metadata;
    this._tunnel = tunnel;
  }
  API2.prototype.getDsn = function() {
    return this._dsnObject;
  };
  API2.prototype.forceEnvelope = function() {
    return !!this._tunnel;
  };
  API2.prototype.getBaseApiEndpoint = function() {
    return getBaseApiEndpoint(this._dsnObject);
  };
  API2.prototype.getStoreEndpoint = function() {
    return getStoreEndpoint(this._dsnObject);
  };
  API2.prototype.getStoreEndpointWithUrlEncodedAuth = function() {
    return getStoreEndpointWithUrlEncodedAuth(this._dsnObject);
  };
  API2.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function() {
    return getEnvelopeEndpointWithUrlEncodedAuth(this._dsnObject, this._tunnel);
  };
  return API2;
}();
function initAPIDetails(dsn, metadata, tunnel) {
  return {
    initDsn: dsn,
    metadata: metadata || {},
    dsn: makeDsn(dsn),
    tunnel
  };
}
function getBaseApiEndpoint(dsn) {
  var protocol = dsn.protocol ? dsn.protocol + ":" : "";
  var port = dsn.port ? ":" + dsn.port : "";
  return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : "") + "/api/";
}
function _getIngestEndpoint(dsn, target) {
  return "" + getBaseApiEndpoint(dsn) + dsn.projectId + "/" + target + "/";
}
function _encodedAuth(dsn) {
  return urlEncode({
    sentry_key: dsn.publicKey,
    sentry_version: SENTRY_API_VERSION
  });
}
function getStoreEndpoint(dsn) {
  return _getIngestEndpoint(dsn, "store");
}
function getStoreEndpointWithUrlEncodedAuth(dsn) {
  return getStoreEndpoint(dsn) + "?" + _encodedAuth(dsn);
}
function _getEnvelopeEndpoint(dsn) {
  return _getIngestEndpoint(dsn, "envelope");
}
function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel) {
  return tunnel ? tunnel : _getEnvelopeEndpoint(dsn) + "?" + _encodedAuth(dsn);
}
function getReportDialogEndpoint(dsnLike, dialogOptions) {
  var dsn = makeDsn(dsnLike);
  var endpoint = getBaseApiEndpoint(dsn) + "embed/error-page/";
  var encodedOptions = "dsn=" + dsnToString(dsn);
  for (var key in dialogOptions) {
    if (key === "dsn") {
      continue;
    }
    if (key === "user") {
      if (!dialogOptions.user) {
        continue;
      }
      if (dialogOptions.user.name) {
        encodedOptions += "&name=" + encodeURIComponent(dialogOptions.user.name);
      }
      if (dialogOptions.user.email) {
        encodedOptions += "&email=" + encodeURIComponent(dialogOptions.user.email);
      }
    } else {
      encodedOptions += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]);
    }
  }
  return endpoint + "?" + encodedOptions;
}

// node_modules/@sentry/core/esm/flags.js
var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

// node_modules/@sentry/core/esm/integration.js
var installedIntegrations = [];
function filterDuplicates(integrations) {
  return integrations.reduce(function(acc, integrations2) {
    if (acc.every(function(accIntegration) {
      return integrations2.name !== accIntegration.name;
    })) {
      acc.push(integrations2);
    }
    return acc;
  }, []);
}
function getIntegrationsToSetup(options) {
  var defaultIntegrations2 = options.defaultIntegrations && __spread(options.defaultIntegrations) || [];
  var userIntegrations = options.integrations;
  var integrations = __spread(filterDuplicates(defaultIntegrations2));
  if (Array.isArray(userIntegrations)) {
    integrations = __spread(integrations.filter(function(integrations2) {
      return userIntegrations.every(function(userIntegration) {
        return userIntegration.name !== integrations2.name;
      });
    }), filterDuplicates(userIntegrations));
  } else if (typeof userIntegrations === "function") {
    integrations = userIntegrations(integrations);
    integrations = Array.isArray(integrations) ? integrations : [integrations];
  }
  var integrationsNames = integrations.map(function(i) {
    return i.name;
  });
  var alwaysLastToRun = "Debug";
  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
    integrations.push.apply(integrations, __spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
  }
  return integrations;
}
function setupIntegration(integration) {
  if (installedIntegrations.indexOf(integration.name) !== -1) {
    return;
  }
  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
  installedIntegrations.push(integration.name);
  IS_DEBUG_BUILD && logger.log("Integration installed: " + integration.name);
}
function setupIntegrations(options) {
  var integrations = {};
  getIntegrationsToSetup(options).forEach(function(integration) {
    integrations[integration.name] = integration;
    setupIntegration(integration);
  });
  addNonEnumerableProperty(integrations, "initialized", true);
  return integrations;
}

// node_modules/@sentry/core/esm/baseclient.js
var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
var BaseClient = function() {
  function BaseClient2(backendClass, options) {
    this._integrations = {};
    this._numProcessing = 0;
    this._backend = new backendClass(options);
    this._options = options;
    if (options.dsn) {
      this._dsn = makeDsn(options.dsn);
    }
  }
  BaseClient2.prototype.captureException = function(exception, hint, scope) {
    var _this = this;
    if (checkOrSetAlreadyCaught(exception)) {
      IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);
      return;
    }
    var eventId = hint && hint.event_id;
    this._process(this._getBackend().eventFromException(exception, hint).then(function(event) {
      return _this._captureEvent(event, hint, scope);
    }).then(function(result) {
      eventId = result;
    }));
    return eventId;
  };
  BaseClient2.prototype.captureMessage = function(message, level, hint, scope) {
    var _this = this;
    var eventId = hint && hint.event_id;
    var promisedEvent = isPrimitive(message) ? this._getBackend().eventFromMessage(String(message), level, hint) : this._getBackend().eventFromException(message, hint);
    this._process(promisedEvent.then(function(event) {
      return _this._captureEvent(event, hint, scope);
    }).then(function(result) {
      eventId = result;
    }));
    return eventId;
  };
  BaseClient2.prototype.captureEvent = function(event, hint, scope) {
    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
      IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);
      return;
    }
    var eventId = hint && hint.event_id;
    this._process(this._captureEvent(event, hint, scope).then(function(result) {
      eventId = result;
    }));
    return eventId;
  };
  BaseClient2.prototype.captureSession = function(session) {
    if (!this._isEnabled()) {
      IS_DEBUG_BUILD && logger.warn("SDK not enabled, will not capture session.");
      return;
    }
    if (!(typeof session.release === "string")) {
      IS_DEBUG_BUILD && logger.warn("Discarded session because of missing or non-string release");
    } else {
      this._sendSession(session);
      session.update({ init: false });
    }
  };
  BaseClient2.prototype.getDsn = function() {
    return this._dsn;
  };
  BaseClient2.prototype.getOptions = function() {
    return this._options;
  };
  BaseClient2.prototype.getTransport = function() {
    return this._getBackend().getTransport();
  };
  BaseClient2.prototype.flush = function(timeout) {
    var _this = this;
    return this._isClientDoneProcessing(timeout).then(function(clientFinished) {
      return _this.getTransport().close(timeout).then(function(transportFlushed) {
        return clientFinished && transportFlushed;
      });
    });
  };
  BaseClient2.prototype.close = function(timeout) {
    var _this = this;
    return this.flush(timeout).then(function(result) {
      _this.getOptions().enabled = false;
      return result;
    });
  };
  BaseClient2.prototype.setupIntegrations = function() {
    if (this._isEnabled() && !this._integrations.initialized) {
      this._integrations = setupIntegrations(this._options);
    }
  };
  BaseClient2.prototype.getIntegration = function(integration) {
    try {
      return this._integrations[integration.id] || null;
    } catch (_oO) {
      IS_DEBUG_BUILD && logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
      return null;
    }
  };
  BaseClient2.prototype._updateSessionFromEvent = function(session, event) {
    var e_1, _a;
    var crashed = false;
    var errored = false;
    var exceptions = event.exception && event.exception.values;
    if (exceptions) {
      errored = true;
      try {
        for (var exceptions_1 = __values(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
          var ex = exceptions_1_1.value;
          var mechanism = ex.mechanism;
          if (mechanism && mechanism.handled === false) {
            crashed = true;
            break;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return))
            _a.call(exceptions_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    var sessionNonTerminal = session.status === "ok";
    var shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
    if (shouldUpdateAndSend) {
      session.update(__assign(__assign({}, crashed && { status: "crashed" }), { errors: session.errors || Number(errored || crashed) }));
      this.captureSession(session);
    }
  };
  BaseClient2.prototype._sendSession = function(session) {
    this._getBackend().sendSession(session);
  };
  BaseClient2.prototype._isClientDoneProcessing = function(timeout) {
    var _this = this;
    return new SyncPromise(function(resolve) {
      var ticked = 0;
      var tick = 1;
      var interval = setInterval(function() {
        if (_this._numProcessing == 0) {
          clearInterval(interval);
          resolve(true);
        } else {
          ticked += tick;
          if (timeout && ticked >= timeout) {
            clearInterval(interval);
            resolve(false);
          }
        }
      }, tick);
    });
  };
  BaseClient2.prototype._getBackend = function() {
    return this._backend;
  };
  BaseClient2.prototype._isEnabled = function() {
    return this.getOptions().enabled !== false && this._dsn !== void 0;
  };
  BaseClient2.prototype._prepareEvent = function(event, scope, hint) {
    var _this = this;
    var _a = this.getOptions(), _b = _a.normalizeDepth, normalizeDepth = _b === void 0 ? 3 : _b, _c = _a.normalizeMaxBreadth, normalizeMaxBreadth = _c === void 0 ? 1e3 : _c;
    var prepared = __assign(__assign({}, event), { event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()), timestamp: event.timestamp || dateTimestampInSeconds() });
    this._applyClientOptions(prepared);
    this._applyIntegrationsMetadata(prepared);
    var finalScope = scope;
    if (hint && hint.captureContext) {
      finalScope = Scope.clone(finalScope).update(hint.captureContext);
    }
    var result = resolvedSyncPromise(prepared);
    if (finalScope) {
      result = finalScope.applyToEvent(prepared, hint);
    }
    return result.then(function(evt) {
      if (evt) {
        evt.sdkProcessingMetadata = __assign(__assign({}, evt.sdkProcessingMetadata), { normalizeDepth: normalize(normalizeDepth) + " (" + typeof normalizeDepth + ")" });
      }
      if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
        return _this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
      }
      return evt;
    });
  };
  BaseClient2.prototype._normalizeEvent = function(event, depth, maxBreadth) {
    if (!event) {
      return null;
    }
    var normalized = __assign(__assign(__assign(__assign(__assign({}, event), event.breadcrumbs && {
      breadcrumbs: event.breadcrumbs.map(function(b) {
        return __assign(__assign({}, b), b.data && {
          data: normalize(b.data, depth, maxBreadth)
        });
      })
    }), event.user && {
      user: normalize(event.user, depth, maxBreadth)
    }), event.contexts && {
      contexts: normalize(event.contexts, depth, maxBreadth)
    }), event.extra && {
      extra: normalize(event.extra, depth, maxBreadth)
    });
    if (event.contexts && event.contexts.trace) {
      normalized.contexts.trace = event.contexts.trace;
    }
    normalized.sdkProcessingMetadata = __assign(__assign({}, normalized.sdkProcessingMetadata), { baseClientNormalized: true });
    return normalized;
  };
  BaseClient2.prototype._applyClientOptions = function(event) {
    var options = this.getOptions();
    var environment = options.environment, release = options.release, dist = options.dist, _a = options.maxValueLength, maxValueLength = _a === void 0 ? 250 : _a;
    if (!("environment" in event)) {
      event.environment = "environment" in options ? environment : "production";
    }
    if (event.release === void 0 && release !== void 0) {
      event.release = release;
    }
    if (event.dist === void 0 && dist !== void 0) {
      event.dist = dist;
    }
    if (event.message) {
      event.message = truncate(event.message, maxValueLength);
    }
    var exception = event.exception && event.exception.values && event.exception.values[0];
    if (exception && exception.value) {
      exception.value = truncate(exception.value, maxValueLength);
    }
    var request = event.request;
    if (request && request.url) {
      request.url = truncate(request.url, maxValueLength);
    }
  };
  BaseClient2.prototype._applyIntegrationsMetadata = function(event) {
    var integrationsArray = Object.keys(this._integrations);
    if (integrationsArray.length > 0) {
      event.sdk = event.sdk || {};
      event.sdk.integrations = __spread(event.sdk.integrations || [], integrationsArray);
    }
  };
  BaseClient2.prototype._sendEvent = function(event) {
    this._getBackend().sendEvent(event);
  };
  BaseClient2.prototype._captureEvent = function(event, hint, scope) {
    return this._processEvent(event, hint, scope).then(function(finalEvent) {
      return finalEvent.event_id;
    }, function(reason) {
      IS_DEBUG_BUILD && logger.error(reason);
      return void 0;
    });
  };
  BaseClient2.prototype._processEvent = function(event, hint, scope) {
    var _this = this;
    var _a = this.getOptions(), beforeSend = _a.beforeSend, sampleRate = _a.sampleRate;
    var transport = this.getTransport();
    function recordLostEvent(outcome, category) {
      if (transport.recordLostEvent) {
        transport.recordLostEvent(outcome, category);
      }
    }
    if (!this._isEnabled()) {
      return rejectedSyncPromise(new SentryError("SDK not enabled, will not capture event."));
    }
    var isTransaction = event.type === "transaction";
    if (!isTransaction && typeof sampleRate === "number" && Math.random() > sampleRate) {
      recordLostEvent("sample_rate", "event");
      return rejectedSyncPromise(new SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
    }
    return this._prepareEvent(event, scope, hint).then(function(prepared) {
      if (prepared === null) {
        recordLostEvent("event_processor", event.type || "event");
        throw new SentryError("An event processor returned null, will not send event.");
      }
      var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
      if (isInternalException || isTransaction || !beforeSend) {
        return prepared;
      }
      var beforeSendResult = beforeSend(prepared, hint);
      return _ensureBeforeSendRv(beforeSendResult);
    }).then(function(processedEvent) {
      if (processedEvent === null) {
        recordLostEvent("before_send", event.type || "event");
        throw new SentryError("`beforeSend` returned `null`, will not send event.");
      }
      var session = scope && scope.getSession && scope.getSession();
      if (!isTransaction && session) {
        _this._updateSessionFromEvent(session, processedEvent);
      }
      _this._sendEvent(processedEvent);
      return processedEvent;
    }).then(null, function(reason) {
      if (reason instanceof SentryError) {
        throw reason;
      }
      _this.captureException(reason, {
        data: {
          __sentry__: true
        },
        originalException: reason
      });
      throw new SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
    });
  };
  BaseClient2.prototype._process = function(promise) {
    var _this = this;
    this._numProcessing += 1;
    void promise.then(function(value) {
      _this._numProcessing -= 1;
      return value;
    }, function(reason) {
      _this._numProcessing -= 1;
      return reason;
    });
  };
  return BaseClient2;
}();
function _ensureBeforeSendRv(rv) {
  var nullErr = "`beforeSend` method has to return `null` or a valid event.";
  if (isThenable(rv)) {
    return rv.then(function(event) {
      if (!(isPlainObject(event) || event === null)) {
        throw new SentryError(nullErr);
      }
      return event;
    }, function(e) {
      throw new SentryError("beforeSend rejected with " + e);
    });
  } else if (!(isPlainObject(rv) || rv === null)) {
    throw new SentryError(nullErr);
  }
  return rv;
}

// node_modules/@sentry/core/esm/request.js
function getSdkMetadataForEnvelopeHeader(api) {
  if (!api.metadata || !api.metadata.sdk) {
    return;
  }
  var _a = api.metadata.sdk, name = _a.name, version = _a.version;
  return { name, version };
}
function enhanceEventWithSdkInfo(event, sdkInfo) {
  if (!sdkInfo) {
    return event;
  }
  event.sdk = event.sdk || {};
  event.sdk.name = event.sdk.name || sdkInfo.name;
  event.sdk.version = event.sdk.version || sdkInfo.version;
  event.sdk.integrations = __spread(event.sdk.integrations || [], sdkInfo.integrations || []);
  event.sdk.packages = __spread(event.sdk.packages || [], sdkInfo.packages || []);
  return event;
}
function createSessionEnvelope(session, api) {
  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
  var envelopeHeaders = __assign(__assign({ sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: dsnToString(api.dsn) });
  var type = "aggregates" in session ? "sessions" : "session";
  var envelopeItem = [{ type }, session];
  var envelope = createEnvelope(envelopeHeaders, [envelopeItem]);
  return [envelope, type];
}
function sessionToSentryRequest(session, api) {
  var _a = __read(createSessionEnvelope(session, api), 2), envelope = _a[0], type = _a[1];
  return {
    body: serializeEnvelope(envelope),
    type,
    url: getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel)
  };
}
function createEventEnvelope(event, api) {
  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
  var eventType = event.type || "event";
  var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
  var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
  enhanceEventWithSdkInfo(event, api.metadata.sdk);
  event.tags = event.tags || {};
  event.extra = event.extra || {};
  if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
    event.tags.skippedNormalization = true;
    event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : "unset";
  }
  delete event.sdkProcessingMetadata;
  var envelopeHeaders = __assign(__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: dsnToString(api.dsn) });
  var eventItem = [
    {
      type: eventType,
      sample_rates: [{ id: samplingMethod, rate: sampleRate }]
    },
    event
  ];
  return createEnvelope(envelopeHeaders, [eventItem]);
}
function eventToSentryRequest(event, api) {
  var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
  var eventType = event.type || "event";
  var useEnvelope = eventType === "transaction" || !!api.tunnel;
  var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
  var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
  enhanceEventWithSdkInfo(event, api.metadata.sdk);
  event.tags = event.tags || {};
  event.extra = event.extra || {};
  if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
    event.tags.skippedNormalization = true;
    event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : "unset";
  }
  delete event.sdkProcessingMetadata;
  var body;
  try {
    body = JSON.stringify(event);
  } catch (err) {
    event.tags.JSONStringifyError = true;
    event.extra.JSONStringifyError = err;
    try {
      body = JSON.stringify(normalize(event));
    } catch (newErr) {
      var innerErr = newErr;
      body = JSON.stringify({
        message: "JSON.stringify error after renormalization",
        extra: { message: innerErr.message, stack: innerErr.stack }
      });
    }
  }
  var req = {
    body,
    type: eventType,
    url: useEnvelope ? getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel) : getStoreEndpointWithUrlEncodedAuth(api.dsn)
  };
  if (useEnvelope) {
    var envelopeHeaders = __assign(__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: dsnToString(api.dsn) });
    var eventItem = [
      {
        type: eventType,
        sample_rates: [{ id: samplingMethod, rate: sampleRate }]
      },
      req.body
    ];
    var envelope = createEnvelope(envelopeHeaders, [eventItem]);
    req.body = serializeEnvelope(envelope);
  }
  return req;
}

// node_modules/@sentry/core/esm/transports/noop.js
var NoopTransport = function() {
  function NoopTransport2() {
  }
  NoopTransport2.prototype.sendEvent = function(_) {
    return resolvedSyncPromise({
      reason: "NoopTransport: Event has been skipped because no Dsn is configured.",
      status: "skipped"
    });
  };
  NoopTransport2.prototype.close = function(_) {
    return resolvedSyncPromise(true);
  };
  return NoopTransport2;
}();

// node_modules/@sentry/core/esm/basebackend.js
var BaseBackend = function() {
  function BaseBackend2(options) {
    this._options = options;
    if (!this._options.dsn) {
      IS_DEBUG_BUILD && logger.warn("No DSN provided, backend will not do anything.");
    }
    this._transport = this._setupTransport();
  }
  BaseBackend2.prototype.eventFromException = function(_exception, _hint) {
    throw new SentryError("Backend has to implement `eventFromException` method");
  };
  BaseBackend2.prototype.eventFromMessage = function(_message, _level, _hint) {
    throw new SentryError("Backend has to implement `eventFromMessage` method");
  };
  BaseBackend2.prototype.sendEvent = function(event) {
    if (this._newTransport && this._options.dsn && this._options._experiments && this._options._experiments.newTransport) {
      var api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
      var env = createEventEnvelope(event, api);
      void this._newTransport.send(env).then(null, function(reason) {
        IS_DEBUG_BUILD && logger.error("Error while sending event:", reason);
      });
    } else {
      void this._transport.sendEvent(event).then(null, function(reason) {
        IS_DEBUG_BUILD && logger.error("Error while sending event:", reason);
      });
    }
  };
  BaseBackend2.prototype.sendSession = function(session) {
    if (!this._transport.sendSession) {
      IS_DEBUG_BUILD && logger.warn("Dropping session because custom transport doesn't implement sendSession");
      return;
    }
    if (this._newTransport && this._options.dsn && this._options._experiments && this._options._experiments.newTransport) {
      var api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
      var _a = __read(createSessionEnvelope(session, api), 1), env = _a[0];
      void this._newTransport.send(env).then(null, function(reason) {
        IS_DEBUG_BUILD && logger.error("Error while sending session:", reason);
      });
    } else {
      void this._transport.sendSession(session).then(null, function(reason) {
        IS_DEBUG_BUILD && logger.error("Error while sending session:", reason);
      });
    }
  };
  BaseBackend2.prototype.getTransport = function() {
    return this._transport;
  };
  BaseBackend2.prototype._setupTransport = function() {
    return new NoopTransport();
  };
  return BaseBackend2;
}();

// node_modules/@sentry/core/esm/sdk.js
function initAndBind(clientClass, options) {
  if (options.debug === true) {
    if (IS_DEBUG_BUILD) {
      logger.enable();
    } else {
      console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
    }
  }
  var hub = getCurrentHub();
  var scope = hub.getScope();
  if (scope) {
    scope.update(options.initialScope);
  }
  var client = new clientClass(options);
  hub.bindClient(client);
}

// node_modules/@sentry/core/esm/transports/base.js
var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
function createTransport(options, makeRequest, buffer) {
  if (buffer === void 0) {
    buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE);
  }
  var rateLimits = {};
  var flush2 = function(timeout) {
    return buffer.drain(timeout);
  };
  function send(envelope) {
    var envCategory = getEnvelopeType(envelope);
    var category = envCategory === "event" ? "error" : envCategory;
    var request = {
      category,
      body: serializeEnvelope(envelope)
    };
    if (isRateLimited(rateLimits, category)) {
      return rejectedSyncPromise({
        status: "rate_limit",
        reason: getRateLimitReason(rateLimits, category)
      });
    }
    var requestTask = function() {
      return makeRequest(request).then(function(_a) {
        var body = _a.body, headers = _a.headers, reason = _a.reason, statusCode = _a.statusCode;
        var status = eventStatusFromHttpCode(statusCode);
        if (headers) {
          rateLimits = updateRateLimits(rateLimits, headers);
        }
        if (status === "success") {
          return resolvedSyncPromise({ status, reason });
        }
        return rejectedSyncPromise({
          status,
          reason: reason || body || (status === "rate_limit" ? getRateLimitReason(rateLimits, category) : "Unknown transport error")
        });
      });
    };
    return buffer.add(requestTask);
  }
  return {
    send,
    flush: flush2
  };
}
function getRateLimitReason(rateLimits, category) {
  return "Too many " + category + " requests, backing off until: " + new Date(disabledUntil(rateLimits, category)).toISOString();
}

// node_modules/@sentry/core/esm/version.js
var SDK_VERSION = "6.19.7";

// node_modules/@sentry/core/esm/integrations/index.js
var integrations_exports = {};
__export(integrations_exports, {
  FunctionToString: () => FunctionToString,
  InboundFilters: () => InboundFilters
});

// node_modules/@sentry/core/esm/integrations/functiontostring.js
var originalFunctionToString;
var FunctionToString = function() {
  function FunctionToString2() {
    this.name = FunctionToString2.id;
  }
  FunctionToString2.prototype.setupOnce = function() {
    originalFunctionToString = Function.prototype.toString;
    Function.prototype.toString = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var context = getOriginalFunction(this) || this;
      return originalFunctionToString.apply(context, args);
    };
  };
  FunctionToString2.id = "FunctionToString";
  return FunctionToString2;
}();

// node_modules/@sentry/core/esm/integrations/inboundfilters.js
var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
var InboundFilters = function() {
  function InboundFilters2(_options) {
    if (_options === void 0) {
      _options = {};
    }
    this._options = _options;
    this.name = InboundFilters2.id;
  }
  InboundFilters2.prototype.setupOnce = function(addGlobalEventProcessor2, getCurrentHub2) {
    addGlobalEventProcessor2(function(event) {
      var hub = getCurrentHub2();
      if (hub) {
        var self_1 = hub.getIntegration(InboundFilters2);
        if (self_1) {
          var client = hub.getClient();
          var clientOptions = client ? client.getOptions() : {};
          var options = _mergeOptions(self_1._options, clientOptions);
          return _shouldDropEvent(event, options) ? null : event;
        }
      }
      return event;
    });
  };
  InboundFilters2.id = "InboundFilters";
  return InboundFilters2;
}();
function _mergeOptions(internalOptions, clientOptions) {
  if (internalOptions === void 0) {
    internalOptions = {};
  }
  if (clientOptions === void 0) {
    clientOptions = {};
  }
  return {
    allowUrls: __spread(internalOptions.whitelistUrls || [], internalOptions.allowUrls || [], clientOptions.whitelistUrls || [], clientOptions.allowUrls || []),
    denyUrls: __spread(internalOptions.blacklistUrls || [], internalOptions.denyUrls || [], clientOptions.blacklistUrls || [], clientOptions.denyUrls || []),
    ignoreErrors: __spread(internalOptions.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),
    ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
  };
}
function _shouldDropEvent(event, options) {
  if (options.ignoreInternal && _isSentryError(event)) {
    IS_DEBUG_BUILD && logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + getEventDescription(event));
    return true;
  }
  if (_isIgnoredError(event, options.ignoreErrors)) {
    IS_DEBUG_BUILD && logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + getEventDescription(event));
    return true;
  }
  if (_isDeniedUrl(event, options.denyUrls)) {
    IS_DEBUG_BUILD && logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
    return true;
  }
  if (!_isAllowedUrl(event, options.allowUrls)) {
    IS_DEBUG_BUILD && logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
    return true;
  }
  return false;
}
function _isIgnoredError(event, ignoreErrors) {
  if (!ignoreErrors || !ignoreErrors.length) {
    return false;
  }
  return _getPossibleEventMessages(event).some(function(message) {
    return ignoreErrors.some(function(pattern) {
      return isMatchingPattern(message, pattern);
    });
  });
}
function _isDeniedUrl(event, denyUrls) {
  if (!denyUrls || !denyUrls.length) {
    return false;
  }
  var url = _getEventFilterUrl(event);
  return !url ? false : denyUrls.some(function(pattern) {
    return isMatchingPattern(url, pattern);
  });
}
function _isAllowedUrl(event, allowUrls) {
  if (!allowUrls || !allowUrls.length) {
    return true;
  }
  var url = _getEventFilterUrl(event);
  return !url ? true : allowUrls.some(function(pattern) {
    return isMatchingPattern(url, pattern);
  });
}
function _getPossibleEventMessages(event) {
  if (event.message) {
    return [event.message];
  }
  if (event.exception) {
    try {
      var _a = event.exception.values && event.exception.values[0] || {}, _b = _a.type, type = _b === void 0 ? "" : _b, _c = _a.value, value = _c === void 0 ? "" : _c;
      return ["" + value, type + ": " + value];
    } catch (oO) {
      IS_DEBUG_BUILD && logger.error("Cannot extract message for event " + getEventDescription(event));
      return [];
    }
  }
  return [];
}
function _isSentryError(event) {
  try {
    return event.exception.values[0].type === "SentryError";
  } catch (e) {
  }
  return false;
}
function _getLastValidUrl(frames) {
  if (frames === void 0) {
    frames = [];
  }
  for (var i = frames.length - 1; i >= 0; i--) {
    var frame = frames[i];
    if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
      return frame.filename || null;
    }
  }
  return null;
}
function _getEventFilterUrl(event) {
  try {
    if (event.stacktrace) {
      return _getLastValidUrl(event.stacktrace.frames);
    }
    var frames_1;
    try {
      frames_1 = event.exception.values[0].stacktrace.frames;
    } catch (e) {
    }
    return frames_1 ? _getLastValidUrl(frames_1) : null;
  } catch (oO) {
    IS_DEBUG_BUILD && logger.error("Cannot extract url for event " + getEventDescription(event));
    return null;
  }
}

// node_modules/@sentry/browser/esm/stack-parsers.js
var UNKNOWN_FUNCTION = "?";
var OPERA10_PRIORITY = 10;
var OPERA11_PRIORITY = 20;
var CHROME_PRIORITY = 30;
var WINJS_PRIORITY = 40;
var GECKO_PRIORITY = 50;
function createFrame(filename, func, lineno, colno) {
  var frame = {
    filename,
    function: func,
    in_app: true
  };
  if (lineno !== void 0) {
    frame.lineno = lineno;
  }
  if (colno !== void 0) {
    frame.colno = colno;
  }
  return frame;
}
var chromeRegex = /^\s*at (?:(.*?) ?\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
var chrome = function(line) {
  var parts = chromeRegex.exec(line);
  if (parts) {
    var isEval = parts[2] && parts[2].indexOf("eval") === 0;
    if (isEval) {
      var subMatch = chromeEvalRegex.exec(parts[2]);
      if (subMatch) {
        parts[2] = subMatch[1];
        parts[3] = subMatch[2];
        parts[4] = subMatch[3];
      }
    }
    var _a = __read(extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]), 2), func = _a[0], filename = _a[1];
    return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
  }
  return;
};
var chromeStackParser = [CHROME_PRIORITY, chrome];
var geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
var gecko = function(line) {
  var _a;
  var parts = geckoREgex.exec(line);
  if (parts) {
    var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
    if (isEval) {
      var subMatch = geckoEvalRegex.exec(parts[3]);
      if (subMatch) {
        parts[1] = parts[1] || "eval";
        parts[3] = subMatch[1];
        parts[4] = subMatch[2];
        parts[5] = "";
      }
    }
    var filename = parts[3];
    var func = parts[1] || UNKNOWN_FUNCTION;
    _a = __read(extractSafariExtensionDetails(func, filename), 2), func = _a[0], filename = _a[1];
    return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
  }
  return;
};
var geckoStackParser = [GECKO_PRIORITY, gecko];
var winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
var winjs = function(line) {
  var parts = winjsRegex.exec(line);
  return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : void 0) : void 0;
};
var winjsStackParser = [WINJS_PRIORITY, winjs];
var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;
var opera10 = function(line) {
  var parts = opera10Regex.exec(line);
  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : void 0;
};
var opera10StackParser = [OPERA10_PRIORITY, opera10];
var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i;
var opera11 = function(line) {
  var parts = opera11Regex.exec(line);
  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : void 0;
};
var opera11StackParser = [OPERA11_PRIORITY, opera11];
var extractSafariExtensionDetails = function(func, filename) {
  var isSafariExtension = func.indexOf("safari-extension") !== -1;
  var isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
  return isSafariExtension || isSafariWebExtension ? [
    func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
    isSafariExtension ? "safari-extension:" + filename : "safari-web-extension:" + filename
  ] : [func, filename];
};

// node_modules/@sentry/browser/esm/eventbuilder.js
function exceptionFromError(ex) {
  var frames = parseStackFrames(ex);
  var exception = {
    type: ex && ex.name,
    value: extractMessage(ex)
  };
  if (frames.length) {
    exception.stacktrace = { frames };
  }
  if (exception.type === void 0 && exception.value === "") {
    exception.value = "Unrecoverable error caught";
  }
  return exception;
}
function eventFromPlainObject(exception, syntheticException, isUnhandledRejection) {
  var event = {
    exception: {
      values: [
        {
          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
          value: "Non-Error " + (isUnhandledRejection ? "promise rejection" : "exception") + " captured with keys: " + extractExceptionKeysForMessage(exception)
        }
      ]
    },
    extra: {
      __serialized__: normalizeToSize(exception)
    }
  };
  if (syntheticException) {
    var frames_1 = parseStackFrames(syntheticException);
    if (frames_1.length) {
      event.stacktrace = { frames: frames_1 };
    }
  }
  return event;
}
function eventFromError(ex) {
  return {
    exception: {
      values: [exceptionFromError(ex)]
    }
  };
}
function parseStackFrames(ex) {
  var stacktrace = ex.stacktrace || ex.stack || "";
  var popSize = getPopSize(ex);
  try {
    return createStackParser(opera10StackParser, opera11StackParser, chromeStackParser, winjsStackParser, geckoStackParser)(stacktrace, popSize);
  } catch (e) {
  }
  return [];
}
var reactMinifiedRegexp = /Minified React error #\d+;/i;
function getPopSize(ex) {
  if (ex) {
    if (typeof ex.framesToPop === "number") {
      return ex.framesToPop;
    }
    if (reactMinifiedRegexp.test(ex.message)) {
      return 1;
    }
  }
  return 0;
}
function extractMessage(ex) {
  var message = ex && ex.message;
  if (!message) {
    return "No error message";
  }
  if (message.error && typeof message.error.message === "string") {
    return message.error.message;
  }
  return message;
}
function eventFromException(exception, hint, attachStacktrace) {
  var syntheticException = hint && hint.syntheticException || void 0;
  var event = eventFromUnknownInput(exception, syntheticException, attachStacktrace);
  addExceptionMechanism(event);
  event.level = Severity.Error;
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}
function eventFromMessage(message, level, hint, attachStacktrace) {
  if (level === void 0) {
    level = Severity.Info;
  }
  var syntheticException = hint && hint.syntheticException || void 0;
  var event = eventFromString(message, syntheticException, attachStacktrace);
  event.level = level;
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}
function eventFromUnknownInput(exception, syntheticException, attachStacktrace, isUnhandledRejection) {
  var event;
  if (isErrorEvent(exception) && exception.error) {
    var errorEvent = exception;
    return eventFromError(errorEvent.error);
  }
  if (isDOMError(exception) || isDOMException(exception)) {
    var domException = exception;
    if ("stack" in exception) {
      event = eventFromError(exception);
    } else {
      var name_1 = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
      var message = domException.message ? name_1 + ": " + domException.message : name_1;
      event = eventFromString(message, syntheticException, attachStacktrace);
      addExceptionTypeValue(event, message);
    }
    if ("code" in domException) {
      event.tags = __assign(__assign({}, event.tags), { "DOMException.code": "" + domException.code });
    }
    return event;
  }
  if (isError(exception)) {
    return eventFromError(exception);
  }
  if (isPlainObject(exception) || isEvent(exception)) {
    var objectException = exception;
    event = eventFromPlainObject(objectException, syntheticException, isUnhandledRejection);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  event = eventFromString(exception, syntheticException, attachStacktrace);
  addExceptionTypeValue(event, "" + exception, void 0);
  addExceptionMechanism(event, {
    synthetic: true
  });
  return event;
}
function eventFromString(input, syntheticException, attachStacktrace) {
  var event = {
    message: input
  };
  if (attachStacktrace && syntheticException) {
    var frames_2 = parseStackFrames(syntheticException);
    if (frames_2.length) {
      event.stacktrace = { frames: frames_2 };
    }
  }
  return event;
}

// node_modules/@sentry/browser/esm/transports/index.js
var transports_exports = {};
__export(transports_exports, {
  BaseTransport: () => BaseTransport,
  FetchTransport: () => FetchTransport,
  XHRTransport: () => XHRTransport,
  makeNewFetchTransport: () => makeNewFetchTransport,
  makeNewXHRTransport: () => makeNewXHRTransport
});

// node_modules/@sentry/browser/esm/flags.js
var IS_DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

// node_modules/@sentry/browser/esm/transports/utils.js
var global = getGlobalObject();
var cachedFetchImpl;
function getNativeFetchImplementation() {
  if (cachedFetchImpl) {
    return cachedFetchImpl;
  }
  if (isNativeFetch(global.fetch)) {
    return cachedFetchImpl = global.fetch.bind(global);
  }
  var document = global.document;
  var fetchImpl = global.fetch;
  if (document && typeof document.createElement === "function") {
    try {
      var sandbox = document.createElement("iframe");
      sandbox.hidden = true;
      document.head.appendChild(sandbox);
      var contentWindow = sandbox.contentWindow;
      if (contentWindow && contentWindow.fetch) {
        fetchImpl = contentWindow.fetch;
      }
      document.head.removeChild(sandbox);
    } catch (e) {
      IS_DEBUG_BUILD2 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e);
    }
  }
  return cachedFetchImpl = fetchImpl.bind(global);
}
function sendReport(url, body) {
  var isRealNavigator = Object.prototype.toString.call(global && global.navigator) === "[object Navigator]";
  var hasSendBeacon = isRealNavigator && typeof global.navigator.sendBeacon === "function";
  if (hasSendBeacon) {
    var sendBeacon = global.navigator.sendBeacon.bind(global.navigator);
    return sendBeacon(url, body);
  }
  if (supportsFetch()) {
    var fetch_1 = getNativeFetchImplementation();
    return forget(fetch_1(url, {
      body,
      method: "POST",
      credentials: "omit",
      keepalive: true
    }));
  }
}

// node_modules/@sentry/browser/esm/transports/base.js
function requestTypeToCategory(ty) {
  var tyStr = ty;
  return tyStr === "event" ? "error" : tyStr;
}
var global2 = getGlobalObject();
var BaseTransport = function() {
  function BaseTransport2(options) {
    var _this = this;
    this.options = options;
    this._buffer = makePromiseBuffer(30);
    this._rateLimits = {};
    this._outcomes = {};
    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);
    this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);
    if (this.options.sendClientReports && global2.document) {
      global2.document.addEventListener("visibilitychange", function() {
        if (global2.document.visibilityState === "hidden") {
          _this._flushOutcomes();
        }
      });
    }
  }
  BaseTransport2.prototype.sendEvent = function(event) {
    return this._sendRequest(eventToSentryRequest(event, this._api), event);
  };
  BaseTransport2.prototype.sendSession = function(session) {
    return this._sendRequest(sessionToSentryRequest(session, this._api), session);
  };
  BaseTransport2.prototype.close = function(timeout) {
    return this._buffer.drain(timeout);
  };
  BaseTransport2.prototype.recordLostEvent = function(reason, category) {
    var _a;
    if (!this.options.sendClientReports) {
      return;
    }
    var key = requestTypeToCategory(category) + ":" + reason;
    IS_DEBUG_BUILD2 && logger.log("Adding outcome: " + key);
    this._outcomes[key] = (_a = this._outcomes[key], _a !== null && _a !== void 0 ? _a : 0) + 1;
  };
  BaseTransport2.prototype._flushOutcomes = function() {
    if (!this.options.sendClientReports) {
      return;
    }
    var outcomes = this._outcomes;
    this._outcomes = {};
    if (!Object.keys(outcomes).length) {
      IS_DEBUG_BUILD2 && logger.log("No outcomes to flush");
      return;
    }
    IS_DEBUG_BUILD2 && logger.log("Flushing outcomes:\n" + JSON.stringify(outcomes, null, 2));
    var url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);
    var discardedEvents = Object.keys(outcomes).map(function(key) {
      var _a = __read(key.split(":"), 2), category = _a[0], reason = _a[1];
      return {
        reason,
        category,
        quantity: outcomes[key]
      };
    });
    var envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));
    try {
      sendReport(url, serializeEnvelope(envelope));
    } catch (e) {
      IS_DEBUG_BUILD2 && logger.error(e);
    }
  };
  BaseTransport2.prototype._handleResponse = function(_a) {
    var requestType = _a.requestType, response = _a.response, headers = _a.headers, resolve = _a.resolve, reject = _a.reject;
    var status = eventStatusFromHttpCode(response.status);
    this._rateLimits = updateRateLimits(this._rateLimits, headers);
    if (this._isRateLimited(requestType)) {
      IS_DEBUG_BUILD2 && logger.warn("Too many " + requestType + " requests, backing off until: " + this._disabledUntil(requestType));
    }
    if (status === "success") {
      resolve({ status });
      return;
    }
    reject(response);
  };
  BaseTransport2.prototype._disabledUntil = function(requestType) {
    var category = requestTypeToCategory(requestType);
    return new Date(disabledUntil(this._rateLimits, category));
  };
  BaseTransport2.prototype._isRateLimited = function(requestType) {
    var category = requestTypeToCategory(requestType);
    return isRateLimited(this._rateLimits, category);
  };
  return BaseTransport2;
}();

// node_modules/@sentry/browser/esm/transports/fetch.js
var FetchTransport = function(_super) {
  __extends(FetchTransport2, _super);
  function FetchTransport2(options, fetchImpl) {
    if (fetchImpl === void 0) {
      fetchImpl = getNativeFetchImplementation();
    }
    var _this = _super.call(this, options) || this;
    _this._fetch = fetchImpl;
    return _this;
  }
  FetchTransport2.prototype._sendRequest = function(sentryRequest, originalPayload) {
    var _this = this;
    if (this._isRateLimited(sentryRequest.type)) {
      this.recordLostEvent("ratelimit_backoff", sentryRequest.type);
      return Promise.reject({
        event: originalPayload,
        type: sentryRequest.type,
        reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
        status: 429
      });
    }
    var options = {
      body: sentryRequest.body,
      method: "POST",
      referrerPolicy: supportsReferrerPolicy() ? "origin" : ""
    };
    if (this.options.fetchParameters !== void 0) {
      Object.assign(options, this.options.fetchParameters);
    }
    if (this.options.headers !== void 0) {
      options.headers = this.options.headers;
    }
    return this._buffer.add(function() {
      return new SyncPromise(function(resolve, reject) {
        void _this._fetch(sentryRequest.url, options).then(function(response) {
          var headers = {
            "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
            "retry-after": response.headers.get("Retry-After")
          };
          _this._handleResponse({
            requestType: sentryRequest.type,
            response,
            headers,
            resolve,
            reject
          });
        }).catch(reject);
      });
    }).then(void 0, function(reason) {
      if (reason instanceof SentryError) {
        _this.recordLostEvent("queue_overflow", sentryRequest.type);
      } else {
        _this.recordLostEvent("network_error", sentryRequest.type);
      }
      throw reason;
    });
  };
  return FetchTransport2;
}(BaseTransport);

// node_modules/@sentry/browser/esm/transports/xhr.js
var XHRTransport = function(_super) {
  __extends(XHRTransport2, _super);
  function XHRTransport2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  XHRTransport2.prototype._sendRequest = function(sentryRequest, originalPayload) {
    var _this = this;
    if (this._isRateLimited(sentryRequest.type)) {
      this.recordLostEvent("ratelimit_backoff", sentryRequest.type);
      return Promise.reject({
        event: originalPayload,
        type: sentryRequest.type,
        reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
        status: 429
      });
    }
    return this._buffer.add(function() {
      return new SyncPromise(function(resolve, reject) {
        var request = new XMLHttpRequest();
        request.onreadystatechange = function() {
          if (request.readyState === 4) {
            var headers = {
              "x-sentry-rate-limits": request.getResponseHeader("X-Sentry-Rate-Limits"),
              "retry-after": request.getResponseHeader("Retry-After")
            };
            _this._handleResponse({ requestType: sentryRequest.type, response: request, headers, resolve, reject });
          }
        };
        request.open("POST", sentryRequest.url);
        for (var header in _this.options.headers) {
          if (Object.prototype.hasOwnProperty.call(_this.options.headers, header)) {
            request.setRequestHeader(header, _this.options.headers[header]);
          }
        }
        request.send(sentryRequest.body);
      });
    }).then(void 0, function(reason) {
      if (reason instanceof SentryError) {
        _this.recordLostEvent("queue_overflow", sentryRequest.type);
      } else {
        _this.recordLostEvent("network_error", sentryRequest.type);
      }
      throw reason;
    });
  };
  return XHRTransport2;
}(BaseTransport);

// node_modules/@sentry/browser/esm/transports/new-fetch.js
function makeNewFetchTransport(options, nativeFetch) {
  if (nativeFetch === void 0) {
    nativeFetch = getNativeFetchImplementation();
  }
  function makeRequest(request) {
    var requestOptions = __assign({ body: request.body, method: "POST", referrerPolicy: "origin" }, options.requestOptions);
    return nativeFetch(options.url, requestOptions).then(function(response) {
      return response.text().then(function(body) {
        return {
          body,
          headers: {
            "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
            "retry-after": response.headers.get("Retry-After")
          },
          reason: response.statusText,
          statusCode: response.status
        };
      });
    });
  }
  return createTransport({ bufferSize: options.bufferSize }, makeRequest);
}

// node_modules/@sentry/browser/esm/transports/new-xhr.js
var XHR_READYSTATE_DONE = 4;
function makeNewXHRTransport(options) {
  function makeRequest(request) {
    return new SyncPromise(function(resolve, _reject) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (xhr.readyState === XHR_READYSTATE_DONE) {
          var response = {
            body: xhr.response,
            headers: {
              "x-sentry-rate-limits": xhr.getResponseHeader("X-Sentry-Rate-Limits"),
              "retry-after": xhr.getResponseHeader("Retry-After")
            },
            reason: xhr.statusText,
            statusCode: xhr.status
          };
          resolve(response);
        }
      };
      xhr.open("POST", options.url);
      for (var header in options.headers) {
        if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
          xhr.setRequestHeader(header, options.headers[header]);
        }
      }
      xhr.send(request.body);
    });
  }
  return createTransport({ bufferSize: options.bufferSize }, makeRequest);
}

// node_modules/@sentry/browser/esm/backend.js
var BrowserBackend = function(_super) {
  __extends(BrowserBackend2, _super);
  function BrowserBackend2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  BrowserBackend2.prototype.eventFromException = function(exception, hint) {
    return eventFromException(exception, hint, this._options.attachStacktrace);
  };
  BrowserBackend2.prototype.eventFromMessage = function(message, level, hint) {
    if (level === void 0) {
      level = Severity.Info;
    }
    return eventFromMessage(message, level, hint, this._options.attachStacktrace);
  };
  BrowserBackend2.prototype._setupTransport = function() {
    if (!this._options.dsn) {
      return _super.prototype._setupTransport.call(this);
    }
    var transportOptions = __assign(__assign({}, this._options.transportOptions), { dsn: this._options.dsn, tunnel: this._options.tunnel, sendClientReports: this._options.sendClientReports, _metadata: this._options._metadata });
    var api = initAPIDetails(transportOptions.dsn, transportOptions._metadata, transportOptions.tunnel);
    var url = getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel);
    if (this._options.transport) {
      return new this._options.transport(transportOptions);
    }
    if (supportsFetch()) {
      var requestOptions = __assign({}, transportOptions.fetchParameters);
      this._newTransport = makeNewFetchTransport({ requestOptions, url });
      return new FetchTransport(transportOptions);
    }
    this._newTransport = makeNewXHRTransport({
      url,
      headers: transportOptions.headers
    });
    return new XHRTransport(transportOptions);
  };
  return BrowserBackend2;
}(BaseBackend);

// node_modules/@sentry/browser/esm/helpers.js
var global3 = getGlobalObject();
var ignoreOnError = 0;
function shouldIgnoreOnError() {
  return ignoreOnError > 0;
}
function ignoreNextOnError() {
  ignoreOnError += 1;
  setTimeout(function() {
    ignoreOnError -= 1;
  });
}
function wrap(fn, options, before) {
  if (options === void 0) {
    options = {};
  }
  if (typeof fn !== "function") {
    return fn;
  }
  try {
    var wrapper = fn.__sentry_wrapped__;
    if (wrapper) {
      return wrapper;
    }
    if (getOriginalFunction(fn)) {
      return fn;
    }
  } catch (e) {
    return fn;
  }
  var sentryWrapped = function() {
    var args = Array.prototype.slice.call(arguments);
    try {
      if (before && typeof before === "function") {
        before.apply(this, arguments);
      }
      var wrappedArguments = args.map(function(arg) {
        return wrap(arg, options);
      });
      return fn.apply(this, wrappedArguments);
    } catch (ex) {
      ignoreNextOnError();
      withScope(function(scope) {
        scope.addEventProcessor(function(event) {
          if (options.mechanism) {
            addExceptionTypeValue(event, void 0, void 0);
            addExceptionMechanism(event, options.mechanism);
          }
          event.extra = __assign(__assign({}, event.extra), { arguments: args });
          return event;
        });
        captureException(ex);
      });
      throw ex;
    }
  };
  try {
    for (var property in fn) {
      if (Object.prototype.hasOwnProperty.call(fn, property)) {
        sentryWrapped[property] = fn[property];
      }
    }
  } catch (_oO) {
  }
  markFunctionWrapped(sentryWrapped, fn);
  addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
  try {
    var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
    if (descriptor.configurable) {
      Object.defineProperty(sentryWrapped, "name", {
        get: function() {
          return fn.name;
        }
      });
    }
  } catch (_oO) {
  }
  return sentryWrapped;
}
function injectReportDialog(options) {
  if (options === void 0) {
    options = {};
  }
  if (!global3.document) {
    return;
  }
  if (!options.eventId) {
    IS_DEBUG_BUILD2 && logger.error("Missing eventId option in showReportDialog call");
    return;
  }
  if (!options.dsn) {
    IS_DEBUG_BUILD2 && logger.error("Missing dsn option in showReportDialog call");
    return;
  }
  var script = global3.document.createElement("script");
  script.async = true;
  script.src = getReportDialogEndpoint(options.dsn, options);
  if (options.onLoad) {
    script.onload = options.onLoad;
  }
  var injectionPoint = global3.document.head || global3.document.body;
  if (injectionPoint) {
    injectionPoint.appendChild(script);
  }
}

// node_modules/@sentry/browser/esm/integrations/index.js
var integrations_exports2 = {};
__export(integrations_exports2, {
  Breadcrumbs: () => Breadcrumbs,
  Dedupe: () => Dedupe,
  GlobalHandlers: () => GlobalHandlers,
  LinkedErrors: () => LinkedErrors,
  TryCatch: () => TryCatch,
  UserAgent: () => UserAgent
});

// node_modules/@sentry/browser/esm/integrations/globalhandlers.js
var GlobalHandlers = function() {
  function GlobalHandlers2(options) {
    this.name = GlobalHandlers2.id;
    this._installFunc = {
      onerror: _installGlobalOnErrorHandler,
      onunhandledrejection: _installGlobalOnUnhandledRejectionHandler
    };
    this._options = __assign({ onerror: true, onunhandledrejection: true }, options);
  }
  GlobalHandlers2.prototype.setupOnce = function() {
    Error.stackTraceLimit = 50;
    var options = this._options;
    for (var key in options) {
      var installFunc = this._installFunc[key];
      if (installFunc && options[key]) {
        globalHandlerLog(key);
        installFunc();
        this._installFunc[key] = void 0;
      }
    }
  };
  GlobalHandlers2.id = "GlobalHandlers";
  return GlobalHandlers2;
}();
function _installGlobalOnErrorHandler() {
  addInstrumentationHandler(
    "error",
    function(data) {
      var _a = __read(getHubAndAttachStacktrace(), 2), hub = _a[0], attachStacktrace = _a[1];
      if (!hub.getIntegration(GlobalHandlers)) {
        return;
      }
      var msg = data.msg, url = data.url, line = data.line, column = data.column, error = data.error;
      if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {
        return;
      }
      var event = error === void 0 && isString(msg) ? _eventFromIncompleteOnError(msg, url, line, column) : _enhanceEventWithInitialFrame(eventFromUnknownInput(error || msg, void 0, attachStacktrace, false), url, line, column);
      event.level = Severity.Error;
      addMechanismAndCapture(hub, error, event, "onerror");
    }
  );
}
function _installGlobalOnUnhandledRejectionHandler() {
  addInstrumentationHandler(
    "unhandledrejection",
    function(e) {
      var _a = __read(getHubAndAttachStacktrace(), 2), hub = _a[0], attachStacktrace = _a[1];
      if (!hub.getIntegration(GlobalHandlers)) {
        return;
      }
      var error = e;
      try {
        if ("reason" in e) {
          error = e.reason;
        } else if ("detail" in e && "reason" in e.detail) {
          error = e.detail.reason;
        }
      } catch (_oO) {
      }
      if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {
        return true;
      }
      var event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(error, void 0, attachStacktrace, true);
      event.level = Severity.Error;
      addMechanismAndCapture(hub, error, event, "onunhandledrejection");
      return;
    }
  );
}
function _eventFromRejectionWithPrimitive(reason) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          value: "Non-Error promise rejection captured with value: " + String(reason)
        }
      ]
    }
  };
}
function _eventFromIncompleteOnError(msg, url, line, column) {
  var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
  var message = isErrorEvent(msg) ? msg.message : msg;
  var name = "Error";
  var groups = message.match(ERROR_TYPES_RE);
  if (groups) {
    name = groups[1];
    message = groups[2];
  }
  var event = {
    exception: {
      values: [
        {
          type: name,
          value: message
        }
      ]
    }
  };
  return _enhanceEventWithInitialFrame(event, url, line, column);
}
function _enhanceEventWithInitialFrame(event, url, line, column) {
  var e = event.exception = event.exception || {};
  var ev = e.values = e.values || [];
  var ev0 = ev[0] = ev[0] || {};
  var ev0s = ev0.stacktrace = ev0.stacktrace || {};
  var ev0sf = ev0s.frames = ev0s.frames || [];
  var colno = isNaN(parseInt(column, 10)) ? void 0 : column;
  var lineno = isNaN(parseInt(line, 10)) ? void 0 : line;
  var filename = isString(url) && url.length > 0 ? url : getLocationHref();
  if (ev0sf.length === 0) {
    ev0sf.push({
      colno,
      filename,
      function: "?",
      in_app: true,
      lineno
    });
  }
  return event;
}
function globalHandlerLog(type) {
  IS_DEBUG_BUILD2 && logger.log("Global Handler attached: " + type);
}
function addMechanismAndCapture(hub, error, event, type) {
  addExceptionMechanism(event, {
    handled: false,
    type
  });
  hub.captureEvent(event, {
    originalException: error
  });
}
function getHubAndAttachStacktrace() {
  var hub = getCurrentHub();
  var client = hub.getClient();
  var attachStacktrace = client && client.getOptions().attachStacktrace;
  return [hub, attachStacktrace];
}

// node_modules/@sentry/browser/esm/integrations/trycatch.js
var DEFAULT_EVENT_TARGET = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
];
var TryCatch = function() {
  function TryCatch2(options) {
    this.name = TryCatch2.id;
    this._options = __assign({ XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true }, options);
  }
  TryCatch2.prototype.setupOnce = function() {
    var global5 = getGlobalObject();
    if (this._options.setTimeout) {
      fill(global5, "setTimeout", _wrapTimeFunction);
    }
    if (this._options.setInterval) {
      fill(global5, "setInterval", _wrapTimeFunction);
    }
    if (this._options.requestAnimationFrame) {
      fill(global5, "requestAnimationFrame", _wrapRAF);
    }
    if (this._options.XMLHttpRequest && "XMLHttpRequest" in global5) {
      fill(XMLHttpRequest.prototype, "send", _wrapXHR);
    }
    var eventTargetOption = this._options.eventTarget;
    if (eventTargetOption) {
      var eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
      eventTarget.forEach(_wrapEventTarget);
    }
  };
  TryCatch2.id = "TryCatch";
  return TryCatch2;
}();
function _wrapTimeFunction(original) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var originalCallback = args[0];
    args[0] = wrap(originalCallback, {
      mechanism: {
        data: { function: getFunctionName(original) },
        handled: true,
        type: "instrument"
      }
    });
    return original.apply(this, args);
  };
}
function _wrapRAF(original) {
  return function(callback) {
    return original.apply(this, [
      wrap(callback, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: getFunctionName(original)
          },
          handled: true,
          type: "instrument"
        }
      })
    ]);
  };
}
function _wrapXHR(originalSend) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var xhr = this;
    var xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
    xmlHttpRequestProps.forEach(function(prop) {
      if (prop in xhr && typeof xhr[prop] === "function") {
        fill(xhr, prop, function(original) {
          var wrapOptions = {
            mechanism: {
              data: {
                function: prop,
                handler: getFunctionName(original)
              },
              handled: true,
              type: "instrument"
            }
          };
          var originalFunction = getOriginalFunction(original);
          if (originalFunction) {
            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
          }
          return wrap(original, wrapOptions);
        });
      }
    });
    return originalSend.apply(this, args);
  };
}
function _wrapEventTarget(target) {
  var global5 = getGlobalObject();
  var proto = global5[target] && global5[target].prototype;
  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
    return;
  }
  fill(proto, "addEventListener", function(original) {
    return function(eventName, fn, options) {
      try {
        if (typeof fn.handleEvent === "function") {
          fn.handleEvent = wrap(fn.handleEvent.bind(fn), {
            mechanism: {
              data: {
                function: "handleEvent",
                handler: getFunctionName(fn),
                target
              },
              handled: true,
              type: "instrument"
            }
          });
        }
      } catch (err) {
      }
      return original.apply(this, [
        eventName,
        wrap(fn, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: getFunctionName(fn),
              target
            },
            handled: true,
            type: "instrument"
          }
        }),
        options
      ]);
    };
  });
  fill(proto, "removeEventListener", function(originalRemoveEventListener) {
    return function(eventName, fn, options) {
      var wrappedEventHandler = fn;
      try {
        var originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
        if (originalEventHandler) {
          originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
        }
      } catch (e) {
      }
      return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
    };
  });
}

// node_modules/@sentry/browser/esm/integrations/breadcrumbs.js
var Breadcrumbs = function() {
  function Breadcrumbs2(options) {
    this.name = Breadcrumbs2.id;
    this._options = __assign({ console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true }, options);
  }
  Breadcrumbs2.prototype.addSentryBreadcrumb = function(event) {
    if (!this._options.sentry) {
      return;
    }
    getCurrentHub().addBreadcrumb({
      category: "sentry." + (event.type === "transaction" ? "transaction" : "event"),
      event_id: event.event_id,
      level: event.level,
      message: getEventDescription(event)
    }, {
      event
    });
  };
  Breadcrumbs2.prototype.setupOnce = function() {
    if (this._options.console) {
      addInstrumentationHandler("console", _consoleBreadcrumb);
    }
    if (this._options.dom) {
      addInstrumentationHandler("dom", _domBreadcrumb(this._options.dom));
    }
    if (this._options.xhr) {
      addInstrumentationHandler("xhr", _xhrBreadcrumb);
    }
    if (this._options.fetch) {
      addInstrumentationHandler("fetch", _fetchBreadcrumb);
    }
    if (this._options.history) {
      addInstrumentationHandler("history", _historyBreadcrumb);
    }
  };
  Breadcrumbs2.id = "Breadcrumbs";
  return Breadcrumbs2;
}();
function _domBreadcrumb(dom) {
  function _innerDomBreadcrumb(handlerData) {
    var target;
    var keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
    if (typeof keyAttrs === "string") {
      keyAttrs = [keyAttrs];
    }
    try {
      target = handlerData.event.target ? htmlTreeAsString(handlerData.event.target, keyAttrs) : htmlTreeAsString(handlerData.event, keyAttrs);
    } catch (e) {
      target = "<unknown>";
    }
    if (target.length === 0) {
      return;
    }
    getCurrentHub().addBreadcrumb({
      category: "ui." + handlerData.name,
      message: target
    }, {
      event: handlerData.event,
      name: handlerData.name,
      global: handlerData.global
    });
  }
  return _innerDomBreadcrumb;
}
function _consoleBreadcrumb(handlerData) {
  var breadcrumb = {
    category: "console",
    data: {
      arguments: handlerData.args,
      logger: "console"
    },
    level: severityFromString(handlerData.level),
    message: safeJoin(handlerData.args, " ")
  };
  if (handlerData.level === "assert") {
    if (handlerData.args[0] === false) {
      breadcrumb.message = "Assertion failed: " + (safeJoin(handlerData.args.slice(1), " ") || "console.assert");
      breadcrumb.data.arguments = handlerData.args.slice(1);
    } else {
      return;
    }
  }
  getCurrentHub().addBreadcrumb(breadcrumb, {
    input: handlerData.args,
    level: handlerData.level
  });
}
function _xhrBreadcrumb(handlerData) {
  if (handlerData.endTimestamp) {
    if (handlerData.xhr.__sentry_own_request__) {
      return;
    }
    var _a = handlerData.xhr.__sentry_xhr__ || {}, method = _a.method, url = _a.url, status_code = _a.status_code, body = _a.body;
    getCurrentHub().addBreadcrumb({
      category: "xhr",
      data: {
        method,
        url,
        status_code
      },
      type: "http"
    }, {
      xhr: handlerData.xhr,
      input: body
    });
    return;
  }
}
function _fetchBreadcrumb(handlerData) {
  if (!handlerData.endTimestamp) {
    return;
  }
  if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
    return;
  }
  if (handlerData.error) {
    getCurrentHub().addBreadcrumb({
      category: "fetch",
      data: handlerData.fetchData,
      level: Severity.Error,
      type: "http"
    }, {
      data: handlerData.error,
      input: handlerData.args
    });
  } else {
    getCurrentHub().addBreadcrumb({
      category: "fetch",
      data: __assign(__assign({}, handlerData.fetchData), { status_code: handlerData.response.status }),
      type: "http"
    }, {
      input: handlerData.args,
      response: handlerData.response
    });
  }
}
function _historyBreadcrumb(handlerData) {
  var global5 = getGlobalObject();
  var from = handlerData.from;
  var to = handlerData.to;
  var parsedLoc = parseUrl(global5.location.href);
  var parsedFrom = parseUrl(from);
  var parsedTo = parseUrl(to);
  if (!parsedFrom.path) {
    parsedFrom = parsedLoc;
  }
  if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
    to = parsedTo.relative;
  }
  if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
    from = parsedFrom.relative;
  }
  getCurrentHub().addBreadcrumb({
    category: "navigation",
    data: {
      from,
      to
    }
  });
}

// node_modules/@sentry/browser/esm/integrations/linkederrors.js
var DEFAULT_KEY = "cause";
var DEFAULT_LIMIT = 5;
var LinkedErrors = function() {
  function LinkedErrors2(options) {
    if (options === void 0) {
      options = {};
    }
    this.name = LinkedErrors2.id;
    this._key = options.key || DEFAULT_KEY;
    this._limit = options.limit || DEFAULT_LIMIT;
  }
  LinkedErrors2.prototype.setupOnce = function() {
    addGlobalEventProcessor(function(event, hint) {
      var self = getCurrentHub().getIntegration(LinkedErrors2);
      return self ? _handler(self._key, self._limit, event, hint) : event;
    });
  };
  LinkedErrors2.id = "LinkedErrors";
  return LinkedErrors2;
}();
function _handler(key, limit, event, hint) {
  if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
    return event;
  }
  var linkedErrors = _walkErrorTree(limit, hint.originalException, key);
  event.exception.values = __spread(linkedErrors, event.exception.values);
  return event;
}
function _walkErrorTree(limit, error, key, stack) {
  if (stack === void 0) {
    stack = [];
  }
  if (!isInstanceOf(error[key], Error) || stack.length + 1 >= limit) {
    return stack;
  }
  var exception = exceptionFromError(error[key]);
  return _walkErrorTree(limit, error[key], key, __spread([exception], stack));
}

// node_modules/@sentry/browser/esm/integrations/useragent.js
var global4 = getGlobalObject();
var UserAgent = function() {
  function UserAgent2() {
    this.name = UserAgent2.id;
  }
  UserAgent2.prototype.setupOnce = function() {
    addGlobalEventProcessor(function(event) {
      if (getCurrentHub().getIntegration(UserAgent2)) {
        if (!global4.navigator && !global4.location && !global4.document) {
          return event;
        }
        var url = event.request && event.request.url || global4.location && global4.location.href;
        var referrer = (global4.document || {}).referrer;
        var userAgent = (global4.navigator || {}).userAgent;
        var headers = __assign(__assign(__assign({}, event.request && event.request.headers), referrer && { Referer: referrer }), userAgent && { "User-Agent": userAgent });
        var request = __assign(__assign({}, url && { url }), { headers });
        return __assign(__assign({}, event), { request });
      }
      return event;
    });
  };
  UserAgent2.id = "UserAgent";
  return UserAgent2;
}();

// node_modules/@sentry/browser/esm/integrations/dedupe.js
var Dedupe = function() {
  function Dedupe2() {
    this.name = Dedupe2.id;
  }
  Dedupe2.prototype.setupOnce = function(addGlobalEventProcessor2, getCurrentHub2) {
    addGlobalEventProcessor2(function(currentEvent) {
      var self = getCurrentHub2().getIntegration(Dedupe2);
      if (self) {
        try {
          if (_shouldDropEvent2(currentEvent, self._previousEvent)) {
            IS_DEBUG_BUILD2 && logger.warn("Event dropped due to being a duplicate of previously captured event.");
            return null;
          }
        } catch (_oO) {
          return self._previousEvent = currentEvent;
        }
        return self._previousEvent = currentEvent;
      }
      return currentEvent;
    });
  };
  Dedupe2.id = "Dedupe";
  return Dedupe2;
}();
function _shouldDropEvent2(currentEvent, previousEvent) {
  if (!previousEvent) {
    return false;
  }
  if (_isSameMessageEvent(currentEvent, previousEvent)) {
    return true;
  }
  if (_isSameExceptionEvent(currentEvent, previousEvent)) {
    return true;
  }
  return false;
}
function _isSameMessageEvent(currentEvent, previousEvent) {
  var currentMessage = currentEvent.message;
  var previousMessage = previousEvent.message;
  if (!currentMessage && !previousMessage) {
    return false;
  }
  if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
    return false;
  }
  if (currentMessage !== previousMessage) {
    return false;
  }
  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }
  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }
  return true;
}
function _isSameExceptionEvent(currentEvent, previousEvent) {
  var previousException = _getExceptionFromEvent(previousEvent);
  var currentException = _getExceptionFromEvent(currentEvent);
  if (!previousException || !currentException) {
    return false;
  }
  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
    return false;
  }
  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }
  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }
  return true;
}
function _isSameStacktrace(currentEvent, previousEvent) {
  var currentFrames = _getFramesFromEvent(currentEvent);
  var previousFrames = _getFramesFromEvent(previousEvent);
  if (!currentFrames && !previousFrames) {
    return true;
  }
  if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
    return false;
  }
  currentFrames = currentFrames;
  previousFrames = previousFrames;
  if (previousFrames.length !== currentFrames.length) {
    return false;
  }
  for (var i = 0; i < previousFrames.length; i++) {
    var frameA = previousFrames[i];
    var frameB = currentFrames[i];
    if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
      return false;
    }
  }
  return true;
}
function _isSameFingerprint(currentEvent, previousEvent) {
  var currentFingerprint = currentEvent.fingerprint;
  var previousFingerprint = previousEvent.fingerprint;
  if (!currentFingerprint && !previousFingerprint) {
    return true;
  }
  if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
    return false;
  }
  currentFingerprint = currentFingerprint;
  previousFingerprint = previousFingerprint;
  try {
    return !!(currentFingerprint.join("") === previousFingerprint.join(""));
  } catch (_oO) {
    return false;
  }
}
function _getExceptionFromEvent(event) {
  return event.exception && event.exception.values && event.exception.values[0];
}
function _getFramesFromEvent(event) {
  var exception = event.exception;
  if (exception) {
    try {
      return exception.values[0].stacktrace.frames;
    } catch (_oO) {
      return void 0;
    }
  } else if (event.stacktrace) {
    return event.stacktrace.frames;
  }
  return void 0;
}

// node_modules/@sentry/browser/esm/client.js
var BrowserClient = function(_super) {
  __extends(BrowserClient2, _super);
  function BrowserClient2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = this;
    options._metadata = options._metadata || {};
    options._metadata.sdk = options._metadata.sdk || {
      name: "sentry.javascript.browser",
      packages: [
        {
          name: "npm:@sentry/browser",
          version: SDK_VERSION
        }
      ],
      version: SDK_VERSION
    };
    _this = _super.call(this, BrowserBackend, options) || this;
    return _this;
  }
  BrowserClient2.prototype.showReportDialog = function(options) {
    if (options === void 0) {
      options = {};
    }
    var document = getGlobalObject().document;
    if (!document) {
      return;
    }
    if (!this._isEnabled()) {
      IS_DEBUG_BUILD2 && logger.error("Trying to call showReportDialog with Sentry Client disabled");
      return;
    }
    injectReportDialog(__assign(__assign({}, options), { dsn: options.dsn || this.getDsn() }));
  };
  BrowserClient2.prototype._prepareEvent = function(event, scope, hint) {
    event.platform = event.platform || "javascript";
    return _super.prototype._prepareEvent.call(this, event, scope, hint);
  };
  BrowserClient2.prototype._sendEvent = function(event) {
    var integration = this.getIntegration(Breadcrumbs);
    if (integration) {
      integration.addSentryBreadcrumb(event);
    }
    _super.prototype._sendEvent.call(this, event);
  };
  return BrowserClient2;
}(BaseClient);

// node_modules/@sentry/browser/esm/sdk.js
var defaultIntegrations = [
  new integrations_exports.InboundFilters(),
  new integrations_exports.FunctionToString(),
  new TryCatch(),
  new Breadcrumbs(),
  new GlobalHandlers(),
  new LinkedErrors(),
  new Dedupe(),
  new UserAgent()
];
function init(options) {
  if (options === void 0) {
    options = {};
  }
  if (options.defaultIntegrations === void 0) {
    options.defaultIntegrations = defaultIntegrations;
  }
  if (options.release === void 0) {
    var window_1 = getGlobalObject();
    if (window_1.SENTRY_RELEASE && window_1.SENTRY_RELEASE.id) {
      options.release = window_1.SENTRY_RELEASE.id;
    }
  }
  if (options.autoSessionTracking === void 0) {
    options.autoSessionTracking = true;
  }
  if (options.sendClientReports === void 0) {
    options.sendClientReports = true;
  }
  initAndBind(BrowserClient, options);
  if (options.autoSessionTracking) {
    startSessionTracking();
  }
}
function showReportDialog(options) {
  if (options === void 0) {
    options = {};
  }
  var hub = getCurrentHub();
  var scope = hub.getScope();
  if (scope) {
    options.user = __assign(__assign({}, scope.getUser()), options.user);
  }
  if (!options.eventId) {
    options.eventId = hub.lastEventId();
  }
  var client = hub.getClient();
  if (client) {
    client.showReportDialog(options);
  }
}
function lastEventId() {
  return getCurrentHub().lastEventId();
}
function forceLoad() {
}
function onLoad(callback) {
  callback();
}
function flush(timeout) {
  var client = getCurrentHub().getClient();
  if (client) {
    return client.flush(timeout);
  }
  IS_DEBUG_BUILD2 && logger.warn("Cannot flush events. No client defined.");
  return resolvedSyncPromise(false);
}
function close(timeout) {
  var client = getCurrentHub().getClient();
  if (client) {
    return client.close(timeout);
  }
  IS_DEBUG_BUILD2 && logger.warn("Cannot flush events and disable SDK. No client defined.");
  return resolvedSyncPromise(false);
}
function wrap2(fn) {
  return wrap(fn)();
}
function startSessionOnHub(hub) {
  hub.startSession({ ignoreDuration: true });
  hub.captureSession();
}
function startSessionTracking() {
  var window = getGlobalObject();
  var document = window.document;
  if (typeof document === "undefined") {
    IS_DEBUG_BUILD2 && logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return;
  }
  var hub = getCurrentHub();
  if (!hub.captureSession) {
    return;
  }
  startSessionOnHub(hub);
  addInstrumentationHandler("history", function(_a) {
    var from = _a.from, to = _a.to;
    if (!(from === void 0 || from === to)) {
      startSessionOnHub(getCurrentHub());
    }
  });
}

// node_modules/@sentry/browser/esm/version.js
var SDK_NAME = "sentry.javascript.browser";

// node_modules/@sentry/browser/esm/index.js
var windowIntegrations = {};
var _window = getGlobalObject();
if (_window.Sentry && _window.Sentry.Integrations) {
  windowIntegrations = _window.Sentry.Integrations;
}
var INTEGRATIONS = __assign(__assign(__assign({}, windowIntegrations), integrations_exports), integrations_exports2);
export {
  BrowserClient,
  Hub,
  INTEGRATIONS as Integrations,
  SDK_NAME,
  SDK_VERSION,
  Scope,
  Session,
  Severity,
  transports_exports as Transports,
  addBreadcrumb,
  addGlobalEventProcessor,
  captureEvent,
  captureException,
  captureMessage,
  close,
  configureScope,
  defaultIntegrations,
  eventFromException,
  eventFromMessage,
  flush,
  forceLoad,
  getCurrentHub,
  getHubFromCarrier,
  init,
  injectReportDialog,
  lastEventId,
  makeMain,
  onLoad,
  setContext,
  setExtra,
  setExtras,
  setTag,
  setTags,
  setUser,
  showReportDialog,
  startTransaction,
  withScope,
  wrap2 as wrap
};
//# sourceMappingURL=@sentry_browser.js.map
